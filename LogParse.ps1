# Generated by Gemini
# 20260106 - first release

$DEBUG = 0

function Set-TicketMap($TicketMap, $QMS, $SerialNumber) {
  foreach ($ticket in $TicketMap) {
    if ($ticket.QMS -eq $QMS -and $ticket.SN -eq $SerialNumber) {
      return $null
    }
  }
  return [PSCustomObject]@{
    QMS                   = $QMS
    SN                    = $SerialNumber
    numOfFailDrv          = 0
    numOfFailDrvBeforeErr = 0
    numOfFailDrvAfterErr  = 0
    DiskList              = @{}
  }
}

# --- [強化] 自動建立磁碟對照表函式 ---
function Get-DiskMap($configPath) {
  # 讀取檔案內容
  $configContent = Get-Content -Path $configPath -Raw

  # 使用正則表達式抓取 SCSI ID 與 Vendor Product ID
  $regexPattern = 'SCSI ID:\s+(?<ID>\d+)[\s\S]*?Vender and Product ID:\s+(?<VendorProduct>.*)[\s\S]*?Revision Number:\s+(?<Rev>\S+)[\s\S]*?Serial Number:\s+(?<SN>\S+)[\s\S]*?Disk Capacity \(blocks\):\s+(?<Capacity>\d+)'

  $matches = [regex]::Matches($configContent, $regexPattern)

  # 解析並存入清單，隨即進行排序
  $DiskList = foreach ($match in $matches) {
    [PSCustomObject]@{
      ID            = [int]$match.Groups['ID'].Value   # 轉成 int 才能正確按數值排序 (避免 10 排在 2 前面)
      VendorProduct = $match.Groups['VendorProduct'].Value.Trim()
      Revision      = $match.Groups['Rev'].Value.Trim()
      SerialNumber  = $match.Groups['SN'].Value.Trim()
      Size          = [int64]([int64]$match.Groups['Capacity'].Value * 512 / 1GB)
    }
  }

  # 按照 ID 進行排序
  return $DiskList | Sort-Object ID
}

function Get-DiskInMap($DisksList, $ScsiId) {
  foreach ($disk in $DisksList) {
    if ($disk.ID -eq $ScsiId) {
      return $disk
    }
  }
  return $null
}

function Set-DiskModel ($DiskModelMap, $VendorProduct) {
  #HGST    HUS726060AL5210
  $cols = $VendorProduct -split '\s+'
  $Vendor = $cols[0]
  $Model = $cols[1]
  foreach ($Disk in $DiskModelMap) {
    if ($Disk.Vendor -eq $Vendor -and $Disk.Model -eq $Model) {
      $Disk.Count++
      #return $Disk
      return $null
    }
  }
  $NewDisk = [PSCustomObject]@{
    Vendor = $Vendor
    Model  = $Model
    Count  = 1
  }
  return $NewDisk
}

function Get-OfficeID {
  param([string]$Path)
    
  if ($Path -match "[A-Za-z]+-\d+") {
    return $Matches[0]
  }
  return "XXX-Unknown"
}

function DateTime-Before ([DateTime]$Time1, [DateTime]$Time2) {
    
  if ((($Time1 - $Time2).TotalMinutes) -gt 0) {
    return -1
  }
  else {
    return 1
  }
}

if (Test-Path ".\MediaErrorPattern.ps1") {
  . .\MediaErrorPattern.ps1
}
else {
  Write-Error "找不到 MediaErrorPattern.ps1，請確保檔案在同目錄。"
  return
}

if (Test-Path ".\LogParseCfg.ps1") {
  . .\LogParseCfg.ps1
}
else {
  Write-Error "找不到 LogParseCfg.ps1，請確保檔案在同目錄。"
  return
}

write-host "開始分析檔案 (門檻：至少需包含 $minMatchCount 筆相關錯誤)..." -ForegroundColor Cyan
$AllQMSTicketDB = New-Object System.Collections.Generic.List[string]
# 準備存儲總結結果的清單
$summaryList = New-Object System.Collections.Generic.List[string]
$summary1List = New-Object System.Collections.Generic.List[string]
$errorlogList = New-Object System.Collections.Generic.List[string]
$logList = New-Object System.Collections.Generic.List[string]
$analysisResultList = New-Object System.Collections.Generic.List[string]

$numOfDrvFailCase = 0
$numOfFailDrvBeforeErr = 0
$numOfFailDrvAfterErr = 0

$analysisDisks = New-Object System.Collections.Generic.List[string]

# 2. 逐一處理 Search_Report.txt 中的檔案
Get-Content $inputFile | ForEach-Object {
  $evtPath = $_.Trim()
    
  if (Test-Path $evtPath) {
    # 搜尋該檔案中「所有」匹配的行
    #$MediaErr_matches = Select-String -Path $evtPath -Pattern $pattern -ErrorAction SilentlyContinue
    $MediaErr_matches = Get-MediaErrorData -logFilePath $evtPath
    $matchCount = $MediaErr_matches.Count
    $DrvFailDetected = 0
        
    if ($matchCount -ge $minMatchCount) {
      $fileInfo = Get-Item $evtPath
      $officeID = Get-OfficeID $evtPath
      $idPart = $fileInfo.Name.Split('.')[0] # 取得第一個點前面的字串
      
      # 建立 Disk Map, 備份 txt config file. 含硬碟資訊
      $conf = "_Conf"
      $configfileName = "$idPart$conf.txt"
      # 1. 設定檔案路徑
      $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
 
      if (-not (Test-Path $configFilePath)) {
        $configfileName = "config.txt"
        $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
        if (-not (Test-Path $configFilePath)) {
          Write-Error "找不到檔案: $configFilePath"
          $errorlogList.Add("找不到檔案: $configFilePath")
          return
        }
      }

      $thisTicket = Set-TicketMap -TicketMap $AllQMSTicketDB -QMS $officeID -SerialNumber $idPart
      if ( $thisTicket -eq $null) {
        $errorlogList.Add("忽略檔案: $configFilePath, $($officeID) 已分析")
        return
      }

      $SortedDiskList = Get-DiskMap -configPath $configfilePath

      # 6. 建立最終的 $DiskMap (以 ID 為 Key 的 Hashtable)
      $DiskMap = @{}
      foreach ($item in $SortedDiskList) {
        $DiskMap[$item.ID.ToString()] = "$($item.VendorProduct) REV:$($item.Revision) (SN:$($item.SerialNumber)) (Capacity:$($item.Size) GB)"
      }

      if ($DEBUG -eq 1 ) {
        # --- 輸出結果展示 ---
        Write-Host "已建立排序後的磁碟對照表 (共 $($SortedDiskList.Count) 筆):" -ForegroundColor Cyan
        $SortedDiskList | Format-Table -AutoSize
      }
      
      # --- 處理總結報告 (只取第一筆) ---
      $firstMatch = $MediaErr_matches[0]
      $summaryList.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")

      # --- 排序 Media error ---
      # 假設 $MediaErr_matches 是您從 Select-String 抓取出來的物件
      $sortedPatternMatchResult = Set-MediaErrorMap -MediaErrorData $MediaErr_matches

      $parsedLogsObj = Build-ParseLog -MediaErrorData $MediaErr_matches

      $finalReport = Split-MediaError-Group -LogsObj $parsedLogsObj

      $analysisReport = Do-Analysis-MediaError-Timestamp -LogsObj $parsedLogsObj

      # 最終排序：先按 ID 排，再按 Sector 數值排
      $sortedFinalReport = $finalReport | Sort-Object DriveID, SectorDec
      $sortedFinalAnalysisReport = $analysisReport | Sort-Object DriveID, StartTime


      $drvFailedMatches = Select-String -Path $evtPath -Pattern $pattern1 -ErrorAction SilentlyContinue

      # --- B. 建立 Office ID 為名的資料夾 ---
      if ( -not $drvFailedMatches) {
        $OutPutDir = "NoDrvFail\" + $officeID
        $allMatches = $MediaErr_matches
      }
      else {
        $OutPutDir = $officeID
        $allMatches = $MediaErr_matches + $drvFailedMatches;
      }
      
      if (!(Test-Path $OutPutDir)) {
        New-Item -ItemType Directory -Path $OutPutDir -Force | Out-Null
        if ($DEBUG -eq 1 ) {
          write-host "建立資料夾: $OutPutDir" -ForegroundColor Gray
        }
      } 

      $sortedDrvFailMatchResult = $allMatches | Sort-Object -Property @{
        # 1. 第一層：依據磁碟 ID 分組
        Expression = {
          if ($_.Line -match 'ID:(?<ID>\d+)') { [int64]$Matches['ID'] } else { 0 }
        }
      }, @{
        # 3. 第二層：按時間排序
        Expression = {
          if ($_.Line -match '(?<Date>\d{2}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})') {
            [DateTime]::ParseExact($Matches['Date'], "yy-MM-dd HH:mm:ss", $null)
          }
          else { [DateTime]::MinValue }
        }
      }

      Copy-Item -Path $configfilePath -Destination (Join-Path $OutPutDir "${idPart}_config_${timestamp}.txt") -Force
      # 備份 xml config file. 含硬碟資訊
      $configfileName = "$idPart$conf.xml"
      $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
      if (-not (Test-Path $configFilePath)) {
        $configfileName = "config.xml"
        $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
        if (-not (Test-Path $configFilePath)) {
          Write-Error "找不到檔案: $configFilePath"
          $errorlogList.Add("找不到檔案: $configFilePath")
        }
        else {
          Copy-Item -Path $configfilePath -Destination (Join-Path $OutPutDir "${idPart}_config_${timestamp}.xml") -Force
        }
      }

      $MediaErrorSectReportOutput = Create-MediaErrorSect-Report -Report $finalReport -DiskMap $DiskMap
      # --- 處理個別錯誤檔案 (完整結果) ---
      $debFileName = "$idPart.deb.0.5.full.txt"
      $debPath = Join-Path $fileInfo.DirectoryName $debFileName
      if ($DEBUG -eq 1 ) {
        write-host "開始處理: $($debFileName)" -ForegroundColor Gray
      }
      # 處理 .deb (全文比對)
      $debList = [System.Collections.Generic.List[string]]::new()
      if (Test-Path $debPath) {
        $debContent = Get-Content $debPath
        foreach ($line in $debContent) {
          if ([string]::IsNullOrWhiteSpace($line)) { continue }
          if ($line -match $debkeywordPattern) {
            $debList.Add($line.Trim())
          }
        }
      }


      # Drive failure detection
      $drvErrMatches = Select-String -Path $evtPath -Pattern $DrvErrPattern -ErrorAction SilentlyContinue
      # $debList - from *.deb.0.5.full.txt, events we needs
      # $drvErrMatches - from *.evt.0.5.full.txt, Events we needs
      # $sortedFinalAnalysisReport - sorted by Drive ID and time
      $ScsiId = -1
      $BadSector = 0
      $DriveIsFailed = 0
      $numOfDrvFail = 0
      $numOfDrvFailBeforeErrInThisQMS = 0
      $numOfDrvFailAfterErrInThisQMS = 0
      $lastTime = $null
      $num = 0
      $startIndex = 0
      $FailureDrvList = New-Object System.Collections.Generic.List[string]
      $sortedFinalAnalysisReport | ForEach-Object {
        $sortedSector = $_
        if ($DEBUG -eq 1) {
          write-host "ID: $($_.DriveID) GB: $($_.StartGB) $($_.StartTime)" -ForegroundColor Gray
        }
        if ($ScsiId -eq -1) {
          $ScsiId = $sortedSector.DriveID
          $BadSector = 1
          $startIndex = 0
          $lastTime = $_.StartTime
        }
        else {
          $num++
          if ($ScsiId -eq $sortedSector.DriveID) {
            if ([Math]::Abs(($_.StartTime - $lastTime).TotalDays) -gt $WeekThresholdDays) {
              $i = $startIndex + 1
              while ($i -le $num) {
                if ([Math]::Abs(($sortedSector.StartTime - $sortedFinalAnalysisReport[$i].StartTime).TotalDays) -gt $WeekThresholdDays) {
                  $BadSector--
                }
                else {
                  break
                }
                $i++
              }
              $lastTime = $sortedFinalAnalysisReport[$i].StartTime
              $startIndex = $i
            }
            else {
              $BadSector++
            }
          }
          else {
            $BadSector = 1
            $ScsiId = $sortedSector.DriveID
            $startIndex = $num - 1
            $lastTime = $_.StartTime
            $DriveIsFailed = 0
          }
          if ($BadSector -gt 9 -and $DriveIsFailed -eq 0) {
            if ($numOfDrvFail -eq 0) {
              $analysisResultList.Add("QMS: $officeID SerialNumber: $idPart")
            }
            $numOfDrvFail++
            $numOfDrvFailCase++
            $analysisResultList.Add("")
            $currentVendor = $DiskMap[$ScsiId.ToString()]
            if ($currentVendor) {
              $analysisResultList.Add("    $($currentVendor)");
              $FailureDrvList += $currentVendor
            }
            $disk = Get-DiskInMap -DisksList $SortedDiskList -ScsiId $ScsiId
            if ($disk) {
              $DiskModel = Set-DiskModel -DiskModelMap $analysisDisks -VendorProduct $disk.VendorProduct
              if ( $DiskModel -ne $null) {
                $analysisDisks += $DiskModel
              }
            }

            $logList.Add("           $($_.StartTime | Get-Date -Format "yy-MM-dd HH-mm-ss") ID:$($ScsiId)     Drive Failure")
            $analysisResultList.Add("           $($_.StartTime | Get-Date -Format "yy-MM-dd HH-mm-ss") ID:$($ScsiId)     Drive Failure")
            $DriveIsFailed = 1
            $DrvFailDetected = 1
            $FailAlogDetected = 0
            $DrvFailBeforeTmout = -1
            $DrvFailBeforeErr = -1
            $EventTime = $sortedSector.StartTime
            $debList | ForEach-Object {
              # Drive ChlNo:21 ID:0 High latency detected(op: 2a, last request latency:1394ms, request amount:7 
              #if ($DrvFailBeforeTmout -le 0 -and $_.Line -match 'M62: Chl (?<CHL>\d+) Id (?<ID>[0-9a-fA-F]+)') {
              if ($DrvFailBeforeTmout -le 0) {
                $foundID = -1
                if ($_ -match 'M62: Chl (?<CHL>\d+) Id (?<ID>[0-9a-fA-F]+)') {    
                  $foundID = [Convert]::ToInt64($Matches['ID'], 16)
                }
                else {
                  if ($_.Line -match 'Drive ChlNo:(?<CHL>\d+) ID (?<ID>\d+) High latency detected') {
                    $foundID = [Convert]::ToInt64($Matches['ID'], 10)
                    if ($foundID -eq $ScsiId) {
                      write-host "$($_)"
                      logList.Add("$($_), target id $($ScsiId), foundId $($foundId)")
                    }
                  }
                }
                if ($foundID -eq $ScsiId) {
                  if ($FailAlogDetected -eq 0 -and $_ -match '(?<DateTime>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
                    # 轉成 DateTime 物件進行精確的時間數值排序
                    $foundTime = [DateTime]::ParseExact($Matches['DateTime'], "yy-MM-dd HH:mm:ss", $null)
                    if ($foundTime -ne $null) {
                      if (($EventTime - $foundTime).TotalMinutes -le 0) {
                        if ($DrvFailBeforeTmout -lt 0) {
                          $DrvFailBeforeTmout = 1
                        }
                        $FailAlogDetected = 1
                        $analysisResultList.Add($_)
                        $logList.Add($_)
                      }
                      else {
                        $DrvFailBeforeTmout = 0
                        $analysisResultList.Add($_)
                        $logList.Add($_)
                      }
                    }
                  }
                }
              }
            }
            $FailAlogDetected = 0
            $drvErrMatches | ForEach-Object {
              if ($_.Line -match 'CH(?:L)?[:\s]+(?<Channel>\d+)\s+ID:(?<ID>\d+)') {
                $foundID = [int64]$Matches['ID']
                if ($foundID -eq $ScsiId) {
                  if ($FailAlogDetected -eq 0 -and $_.Line -match '(?<Date>\d{2}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})') {
                    $foundTime = [DateTime]::ParseExact($Matches['Date'], "yy-MM-dd HH:mm:ss", $null)
                    if ($foundTime -ne $null) {
                      if (($EventTime - $foundTime).TotalMinutes -le 0) {
                        if ($DrvFailBeforeErr -lt 0) {
                          $DrvFailBeforeErr = 1
                        }
                        $FailAlogDetected = 1
                        $analysisResultList.Add($_.Line)
                        $logList.Add($_.Line)
                      }
                      else {
                        $DrvFailBeforeErr = 0
                        $analysisResultList.Add($_.Line)
                        $logList.Add($_.Line)
                      }
                    }
                  }
                }
              }
            }
            if ($DrvFailBeforeErr -ge 0 -or $DrvFailBeforeTmout -ge 0) {
              if ($DrvFailBeforeErr -eq 0 -or $DrvFailBeforeTmout -eq 0) {
                $numOfFailDrvAfterErr++
                $numOfDrvFailAfterErrInThisQMS++
              }
              else {
                $numOfFailDrvBeforeErr++
                $numOfDrvFailBeforeErrInThisQMS++
              }
            }
          }
        }
      }
      if ($numOfDrvFail -gt 0) {
        $analysisResultList.Add("     number of the failure drives: $($numOfDrvFail)")
        $analysisResultList.Add("     number of before error : $($numOfDrvFailBeforeErrInThisQMS)")
        $analysisResultList.Add("     number of after error: $($numOfDrvFailAfterErrInThisQMS)")
        $analysisResultList.Add("-----------------------------------------------------------------------------------")
        $analysisResultList.Add("")
        $thisTicket.numOfFailDrv = $numOfDrvFail
        $thisTicket.numOfFailDrvBeforeErr = $numOfDrvFailBeforeErrInThisQMS
        $thisTicket.numOfFailDrvAfterErr = $numOfDrvFailAfterErrInThisQMS
        $thisTicket.DiskList = $FailureDrvList
        $AllQMSTicketDB += $thisTicket
      }

      # Starting backup the result
      $baseName = $fileInfo.BaseName # 不含副檔名的檔名
      $timestamp = $fileInfo.CreationTime.ToString("yyyyMMdd_HHmmss")


      $patternMatchOutPath = Join-Path $OutPutDir "${baseName}_${timestamp}_mediaerror.txt"

      # 儲存與輸出至 xxx_mediaerror.txt
      $MediaErrorSectReportOutput | Out-File -FilePath $patternMatchOutPath -Encoding UTF8
      $sortedFinalReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | Format-Table -AutoSize |
      Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      $sortedFinalAnalysisReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | Format-Table -AutoSize |
      Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      $sortedDrvFailMatchResult.Line  | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8

      # 儲存與輸出至 xxx_mediaerror_sorted.txt
      $patternMatchOutPath = Join-Path $OutPutDir "${baseName}_${timestamp}_mediaerror_sorted.txt"
      $MediaErrorSectReportOutput | Out-File -FilePath $patternMatchOutPath -Encoding UTF8
      $sortedPatternMatchResult.Line | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      $SortedDiskList | Format-Table -AutoSize | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      if ($DEBUG -eq 1 ) {
        $MediaErrorSectReportOutput | Write-Host -ForegroundColor White # 直接在畫面上顯示
      }
      # 定義檔名
      $csvFileName = "Disk_Error_Report_${baseName}_${timestamp}.csv"
      $csvFilePath = Join-Path $OutPutDir $csvFileName

      # 將結果選取需要的欄位並匯出
      $sortedFinalReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | 
      Export-Csv -Path $csvFilePath -NoTypeInformation -Encoding UTF8

      if ($DEBUG -eq 1) {
        Write-Host "Excel 報表已儲存至: $csvFileName" -ForegroundColor Green
      }
            
      if ( $drvFailedMatches) {
        # --- 使用 List 物件確保資料被抓取 ---
        $evtList = [System.Collections.Generic.List[string]]::new()
        
        # 逐行讀取 .evt
        $evtContent = Get-Content $evtPath
        foreach ($line in $evtContent) {
          $trimmedLine = $line.Trim()
            
          # 排除空行與星號開頭
          if ([string]::IsNullOrWhiteSpace($trimmedLine)) { continue }
            
          $cols = $trimmedLine -split '\s+'
            
          # 檢查第 7 欄 (索引 6)
          if ($cols.Count -ge 7) {
            if ($cols[6] -match $keywordPattern2) {
              $evtList.Add($trimmedLine) # 存入 List，不保留行首空白
            }
          }
        }
        # --- 新增判斷邏輯：僅處理達到門檻的檔案 ---
        if ( $evtList) {
          $summary1List.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")

          # --- 合併與排序 ---
          $allMatches = $evtList + $debList
            
          $sortedResults = $allMatches | Sort-Object {
            # 使用正規表達式提取日期時間格式 (YY-MM-DD HH:MM:SS)
            if ($_ -match '(?<DateTime>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
              # 轉成 DateTime 物件進行精確的時間數值排序
              [DateTime]::ParseExact($Matches['DateTime'], "yy-MM-dd HH:mm:ss", $null)
            }
            else {
              # 如果該行沒有日期，排在最前面或最後面
              [DateTime]::MinValue
            }
          }

          $targetFileName = "${baseName}_${timestamp}_error.txt"
          # 完整儲存路徑：資料夾名稱 / 檔名
          $finalOutputPath = Join-Path $OutPutDir $targetFileName
          # 3. 儲存與輸出
          $MediaErrorSectReportOutput | Out-File -FilePath $finalOutputPath -Encoding UTF8
          # 將所有匹配的行內容寫入該個別檔案
          $sortedResults | Out-File -FilePath $finalOutputPath -Append -Encoding utf8
                    

          # 備份原始 .evt 檔
          # 目的地檔名維持原樣，但存放在 $OutPutDir 下
          Copy-Item -Path $evtPath -Destination (Join-Path $OutPutDir "${BaseName}_${timestamp}.txt") -Force
            
          # 備份原始 .deb 檔 (如果存在)
          if (Test-Path $debPath) {
            $debFileInfo = Get-Item $debPath
            $debbaseName = $debFileInfo.BaseName # 不含副檔名的檔名
            Copy-Item -Path $debPath -Destination (Join-Path $OutPutDir "${debbaseName}_${timestamp}.txt") -Force
          }
          if ($DEBUG -eq 1) {
            write-host "[成功] $officeID \ $idPart -> 檔案已儲存" -ForegroundColor Green
          }
          $logList.Add("[成功] $officeID \ $idPart -> 檔案已儲存")
        }
      }
      else {
        if ($DEBUG -eq 1) {
          write-host "[跳過] 檔案: $($evtPath) (Drive還沒失效)" -ForegroundColor Gray
        }
        $logList.Add("[跳過] 檔案: $($evtPath) (Drive還沒失效)")
        if ($DrvFailDetected -eq 1) {
          $analysisResultList.Add("[跳過] 檔案: $($evtPath) (Drive還沒失效)")
        }
      }
    }
    else {
      # 選項：可以顯示哪些檔案被忽略了
      if ($matchCount -gt 0) {
        if ($DEBUG -eq 1) {
          write-host "[跳過] 檔案: $($evtPath) (僅 $matchCount 筆，未達門檻)" -ForegroundColor Gray
        }
        $logList.Add("[跳過] 檔案: $($evtPath) (僅 $matchCount 筆，未達門檻)")
      }
    }
  }
}

# 3. 輸出總結報告
if ($summaryList.Count -gt 0) {
  $summaryList | Out-File -FilePath $resultFile -Encoding utf8
  if ($summary1List.Count -gt 0) {
    $summary1List | Out-File -FilePath $resultFile1 -Encoding utf8
    write-host "`n[完成] 總結報告已存至: $summaryFile1" -ForegroundColor Green
    write-host "[完成] 共處理了 $($summary1List.Count) 個包含錯誤的檔案。" -ForegroundColor Green
  }
}
else {
  write-host "`n未發現任何符合條件的檔案。" -ForegroundColor Yellow
}

if ($logList.Count -gt 0) {
  $logList | Out-File -FilePath $logFile -Encoding utf8
}

if ($errorlogList.Count -gt 0) {
  $errorlogList | Out-File -FilePath $errrologFile -Encoding utf8
}

if ($analysisResultList.Count -gt 0) {
  $summaryList = New-Object System.Collections.Generic.List[string]
  $analysisResultList.Add("Total case: $($numOfDrvFailCase), Failed Drive before errors: $($numOfFailDrvBeforeErr), Failed Drive after errors: $($numOfFailDrvAfterErr)")
  $analysisFileTxt = $analysisFile + ".txt"
  $analysisResultList | Out-File -FilePath $analysisFileTxt -Encoding utf8
  $numOfQMS = $AllQMSTicketDB.Count
  $numOfDisk = 0
  $numOfBefore = 0
  $numOfAfter = 0
  $summaryList.Add("============================================================")
  $summaryList.Add("QMS        SN     numOfFailDrv numOfFailDrvBeforeErr numOfFailDrvAfterErr")
  $summaryList.Add("---        --     ------------ --------------------- --------------------")
  # Ticket summary
  foreach ($ticket in $AllQMSTicketDB) {
    $summaryList.Add("$($ticket.QMS) $($ticket.SN)          $($ticket.numOfFailDrv)              $($ticket.numOfFailDrvBeforeErr)                $($ticket.numOfFailDrvAfterErr)")
    foreach ($disk in $ticket.DiskList) {
      $summaryList.Add("   | $($disk)")
    }
    $numOfDisk += $ticket.numOfFailDrv
    $numOfBefore += $ticket.numOfFailDrvBeforeErr
    $numOfAfter += $ticket.numOfFailDrvAfterErr
  }
  $summaryList.Add("---        --     ------------ --------------------- --------------------")
  $summaryList.Add("     $($numOfQMS)                   $($numOfDisk)             $($numOfBefore)               $($numOfAfter)        $($numOfDisk - $numOfBefore - $numOfAfter)")
  $summaryFileTxt = $summaryFile + ".txt"
  $summaryList | Out-File -FilePath $summaryFileTxt -Encoding utf8
  $summaryFileTxt = $summaryFile + "1.txt"
  $AllQMSTicketDB | Format-Table -AutoSize | Out-File -FilePath $summaryFileTxt -Encoding utf8
  if ($analysisDisks.Count -gt 0) {
    $analysisDisks | Format-Table -AutoSize | Out-File -FilePath $summaryFileTxt -Append -Encoding utf8
  }
}

write-host "Total case: $($numOfDrvFailCase), Failed Drive before errors: $($numOfFailDrvBeforeErr), Failed Drive after errors: $($numOfFailDrvAfterErr)"
#$AllQMSTicketDB | Format-Table -AutoSize
pause