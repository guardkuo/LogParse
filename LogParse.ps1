# Generated by Gemini
# 20260106 - first release

$DEBUG = 0

# 建立統計物件的函式
#function New-EventSummary ($Entries) {
function MediaErrorBadSector ($Entries) {
  $minSector = ($Entries | Sort-Object SectorDec)[0].SectorDec
  $duration = ($Entries | Sort-Object Time)[-1].Time - ($Entries | Sort-Object Time)[0].Time
  return [PSCustomObject]@{
    DriveID     = $Entries[0].ID
    StartSector = "0x{0:X}" -f $minSector
    SectorDec   = $minSector
    GB_Zone     = "GB_" + $Entries[0].GBZone
    StartGB     = $Entries[0].GBZone
    ErrorCount  = $Entries.Count
    StartTime   = ($Entries | Sort-Object Time)[0].Time
    EndTime     = ($Entries | Sort-Object Time)[-1].Time
    Duration    = "$([Math]::Round($duration.TotalDays, 1)) days"
  }
}

. .\LogParseCfg.ps1

write-host "開始分析檔案 (門檻：至少需包含 $minMatchCount 行匹配內容)..." -ForegroundColor Cyan

# 準備存儲總結結果的清單
$summaryList = New-Object System.Collections.Generic.List[string]
$summary1List = New-Object System.Collections.Generic.List[string]
$errorlogList = New-Object System.Collections.Generic.List[string]
$logList = New-Object System.Collections.Generic.List[string]

# 2. 逐一處理 Search_Report.txt 中的檔案
Get-Content $inputFile | ForEach-Object {
  $evtPath = $_.Trim()
    
  if (Test-Path $evtPath) {
    # 搜尋該檔案中「所有」匹配的行
    $Pattern_matches = Select-String -Path $evtPath -Pattern $pattern -ErrorAction SilentlyContinue
    $matchCount = $Pattern_matches.Count
        
    if ($matchCount -ge $minMatchCount) {
      # --- 處理總結報告 (只取第一筆) ---
      $firstMatch = $Pattern_matches[0]
      $summaryList.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")

      # --- 排序 Media error ---
      # 假設 $Pattern_matches 是您從 Select-String 抓取出來的物件
      $sortedPatternMatchResult = $Pattern_matches | Sort-Object -Property @{
        # 1. 第一層：依據磁碟 ID 分組
        Expression = {
          if ($_.Line -match 'ID:(?<ID>\d+)') { [int64]$Matches['ID'] } else { 0 }
        }
      }, @{
        # 2. 第二層：1GB 區域對齊 (Grouping by GB range)
        Expression = {
          if ($_.Line -match '0x(?<Sector>[0-9A-Fa-f]+)') {
            $decSector = [Convert]::ToInt64($Matches['Sector'], 16)
            # 將 Sector 除以 1GB 的總數並取整數，得到「第幾個 GB」
            [Math]::Floor($decSector / $SectorsPerGB)
          }
          else { 0 }
        }
      }, @{
        # 3. 第三層：在同一個 1GB 區域內，按時間排序
        Expression = {
          if ($_.Line -match '(?<Date>\d{2}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})') {
            [DateTime]::ParseExact($Matches['Date'], "yy-MM-dd HH:mm:ss", $null)
          }
          else { [DateTime]::MinValue }
        }
      }

      # 1. 預處理：解析 Log 並轉為物件
      # 1. 預處理：解析 Log 並轉為物件 (支援 64-bit Sector)
      $parsedLogs = $Pattern_matches | ForEach-Object {
        $line = $_.Line
        $foundID = $null
        $foundTime = $null
        $foundSector = 0

        # 匹配 ID (精確抓取 ID:16, ID:17 等)
        if ($line -match 'ID:(?<ID>\d+)') {
          $foundID = [int64]$Matches['ID']
        }

        # 匹配日期時間 (YY-MM-DD HH:MM:SS)
        if ($line -match '(?<DT>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
          $foundTime = [DateTime]::ParseExact($Matches['DT'], "yy-MM-dd HH:mm:ss", $null)
        }

        # 匹配 Sector (支援 64-bit Hex，例如 0xFFFFFFFF 或更長位址)
        if ($line -match '0x(?<Hex>[0-9A-Fa-f]+)') {
          try {
            # 使用長整數處理位址
            $foundSector = [Convert]::ToInt64($Matches['Hex'], 16)
          }
          catch {
            $foundSector = 0 
          }
        }

        if ($null -ne $foundID -and $null -ne $foundTime) {
          [PSCustomObject]@{
            ID        = $foundID
            SectorDec = $foundSector
            SectorHex = "0x{0:X}" -f $foundSector
            GBZone    = [Math]::Floor($foundSector / $SectorsPerGB)
            Time      = $foundTime
            RawLine   = $line
          }
        }
      }

      # 2. 分組與事件處理
      $finalReport = @()
      $groups = $parsedLogs | Group-Object ID, GBZone

      foreach ($g in $groups) {
        # 區域內按 Sector 排序，確保分析連續性
        $sortedEntries = $g.Group | Sort-Object SectorDec, Time
    
        $currentEventEntries = @()
        $lastTime = $null

        foreach ($entry in $sortedEntries) {
          # 時間間隔判定：超過一週則分割
          if ($null -ne $lastTime -and [Math]::Abs(($entry.Time - $lastTime).TotalDays) -gt $WeekThresholdDays) {
            $finalReport += MediaErrorBadSector -Entries $currentEventEntries
            $currentEventEntries = @()
          }
        
          $currentEventEntries += $entry
          $lastTime = $entry.Time
        }
    
        if ($currentEventEntries.Count -gt 0) {
          $finalReport += MediaErrorBadSector -Entries $currentEventEntries
        }
      }


      # 3. 最終排序：先按 ID 排，再按 Sector 數值排
      $sortedFinalReport = $finalReport | Sort-Object DriveID, SectorDec

      # 4. 輸出結果
      if ($DEBUG -eq 1 ) {
        Write-Host "`n[統計摘要]" -ForegroundColor Cyan
        Write-Host "總受損 GB 區域數: " ($groups.Count)
        Write-Host "總事件處理數 (跨週分割): " ($finalReport.Count) -ForegroundColor Yellow
        $sortedFinalReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | Format-Table -AutoSize
      }

      $fileInfo = Get-Item $evtPath
      # --- A. 提取路徑中的 Office ID (例如 OFY-508427) ---
      $pathParts = $evtPath -split '\\'
      $officeID = if ($pathParts.Count -ge 6) { $pathParts[5] } else { "Unknown" }
      $idPart = $fileInfo.Name.Split('.')[0] # 取得第一個點前面的字串
      # --- B. 建立 Office ID 為名的資料夾 ---
      if (!(Test-Path $officeID)) {
        New-Item -ItemType Directory -Path $officeID -Force | Out-Null
        if ($DEBUG -eq 1 ) {
          write-host "建立資料夾: $officeID" -ForegroundColor Gray
        }
      }

      # 建立 Disk Map, 備份 txt config file. 含硬碟資訊
      $conf = "_Conf"
      $configfileName = "$idPart$conf.txt"
      # 1. 設定檔案路徑
      $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName


      # 2. 讀取檔案內容
      if (-not (Test-Path $configFilePath)) {
        $configfileName = "config.txt"
        $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
        if (-not (Test-Path $configFilePath)) {
          Write-Error "找不到檔案: $configFilePath"
          $errorlogList.Add("找不到檔案: $configFilePath")
          return
        }
      }
      $configContent = Get-Content -Path $configFilePath -Raw

      # 3. 使用正則表達式抓取 SCSI ID 與 Vendor Product ID
      # 這裡包含 ID、VendorProduct，Serial Number，Capacity
      #$regexPattern = 'SCSI ID:\s+(?<ID>\d+)[\s\S]*?Vender and Product ID:\s+(?<VendorProduct>.*)'
      #$regexPattern = 'SCSI ID:\s+(?<ID>\d+)[\s\S]*?Vender and Product ID:\s+(?<VendorProduct>.*)[\s\S]*?Serial Number:\s+(?<SN>\S+)'
      #$regexPattern = 'SCSI ID:\s+(?<ID>\d+)[\s\S]*?Vender and Product ID:\s+(?<VendorProduct>.*)[\s\S]*?Revision Number:\s+(?<Rev>\S+)[\s\S]*?Serial Number:\s+(?<SN>\S+)'
      #$regexPattern = 'SCSI ID:\s+(?<ID>\d+)[\s\S]*?Vender and Product ID:\s+(?<VendorProduct>.*)[\s\S]*?Revision Number:\s+(?<Rev>\S+)[\s\S]*?Serial Number:\s+(?<SN>\S+[\s\S]*?Disk Capacity \(blocks\):\s+(?<Capacity>\S+)'
      #$regexPattern = 'SCSI ID:\s+(?<ID>\d+)[\s\S]*?Vender and Product ID:\s+(?<VendorProduct>.*)[\s\S]*?Revision Number:\s+(?<Rev>\S+)[\s\S]*?Serial Number:\s+(?<SN>\S+)[\s\S]*?Disk Capacity \(blocks\):\s+(?<Blocks>\d+)'
      $regexPattern = 'SCSI ID:\s+(?<ID>\d+)[\s\S]*?Vender and Product ID:\s+(?<VendorProduct>.*)[\s\S]*?Revision Number:\s+(?<Rev>\S+)[\s\S]*?Serial Number:\s+(?<SN>\S+)[\s\S]*?Disk Capacity \(blocks\):\s+(?<Capacity>\d+)'
      #$matches = [regex]::Matches($configContent, $regexPattern)

      $matches = [regex]::Matches($configContent, $regexPattern)

      # 4. 解析並存入清單，隨即進行排序
      $DiskList = foreach ($match in $matches) {
        [PSCustomObject]@{
          ID            = [int]$match.Groups['ID'].Value   # 轉成 int 才能正確按數值排序 (避免 10 排在 2 前面)
          VendorProduct = $match.Groups['VendorProduct'].Value.Trim()
          Revision      = $match.Groups['Rev'].Value.Trim()
          SerialNumber  = $match.Groups['SN'].Value.Trim()
          Size          = $match.Groups['Capacity'].Value.Trim()
        }
      }

      # 5. 按照 ID 進行排序
      $SortedDiskList = $DiskList | Sort-Object ID

      # 6. 建立最終的 $DiskMap (以 ID 為 Key 的 Hashtable)
      $DiskMap = @{}
      foreach ($item in $SortedDiskList) {
        $DiskMap[$item.ID.ToString()] = "$($item.VendorProduct) REV:$($item.Revision) (SN:$($item.SerialNumber)) (Capacity:$($item.Size))"
      }

      if ($DEBUG -eq 1 ) {
        # --- 輸出結果展示 ---
        Write-Host "已建立排序後的磁碟對照表 (共 $($SortedDiskList.Count) 筆):" -ForegroundColor Cyan
        $SortedDiskList | Format-Table -AutoSize
      }



      Copy-Item -Path $configfilePath -Destination (Join-Path $officeID "${idPart}_config_${timestamp}.txt") -Force
      # 備份 xml config file. 含硬碟資訊
      $configfileName = "$idPart$conf.xml"
      $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
      if (-not (Test-Path $configFilePath)) {
        $configfileName = "config.xml"
        $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
        if (-not (Test-Path $configFilePath)) {
          Write-Error "找不到檔案: $configFilePath"
          $errorlogList.Add("找不到檔案: $configFilePath")
        }
        else {
          Copy-Item -Path $configfilePath -Destination (Join-Path $officeID "${idPart}_config_${timestamp}.xml") -Force
        }
      }

      $baseName = $fileInfo.BaseName # 不含副檔名的檔名
      $timestamp = $fileInfo.CreationTime.ToString("yyyyMMdd_HHmmss")
      $patternMatchFileName = "${baseName}_${timestamp}_mediaerror.txt"
      $patternMatchOutPath = Join-Path $officeID $patternMatchFileName
      $Pattern_matches.Line | Out-File -FilePath $patternMatchOutPath -Encoding utf8

      $patternMatchFileName = "${baseName}_${timestamp}_mediaerror_sorted.txt"
      $patternMatchOutPath = Join-Path $officeID $patternMatchFileName

      # --- 產生表格化 Text 與 畫面顯示 ---
      $reportOutput = New-Object System.Collections.Generic.List[string]
      $reportOutput.Add("=== Disk Media Error Analysis Report (Grouped by ID) ===")
      $reportOutput.Add("Generated on: $(Get-Date)")
      $reportOutput.Add("Total number of damaged GB areas: $($groups.Count)")
      $reportOutput.Add("")

      # 按 ID 分組顯示
      $groupedByID = $finalReport | Sort-Object DriveID, SectorDec | Group-Object DriveID

      foreach ($driveGroup in $groupedByID) {
        # 假設 $foundID 是您從 Error Log 中抓到的 ID (例如 202)
        $currentVendor = $DiskMap[$driveGroup.Name]

        $header = ">>> Drive ID: $($driveGroup.Name) (Total Events: $($driveGroup.Count))"
        $reportOutput.Add($header)
        $reportOutput.Add("-" * $header.Length)
        if ($currentVendor) {
          $reportOutput.Add($currentVendor)
        }
    
        # 格式化該 ID 下的事件清單
        $table = $driveGroup.Group | Select-Object StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | Format-Table -AutoSize | Out-String
        $reportOutput.Add($table)
        $reportOutput.Add("") # 空行隔開不同 ID
      }

      # 3. 儲存與輸出
      $reportOutput | Out-File -FilePath $patternMatchOutPath -Encoding UTF8
      if ($DEBUG -eq 1 ) {
        $reportOutput | Write-Host -ForegroundColor White # 直接在畫面上顯示
      }

      $sortedPatternMatchResult.Line | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      $SortedDiskList  | Format-Table -AutoSize | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8

      # 定義檔名

      $csvFileName = "Disk_Error_Report_${baseName}_${timestamp}.csv"
      $csvFilePath = Join-Path $officeID $csvFileName

      # 將結果選取需要的欄位並匯出
      $sortedFinalReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | 
      Export-Csv -Path $csvFilePath -NoTypeInformation -Encoding UTF8

      if ($DEBUG -eq 1) {
        Write-Host "Excel 報表已儲存至: $csvFileName" -ForegroundColor Green
      }
      $allMatches = Select-String -Path $evtPath -Pattern $pattern1 -List -ErrorAction SilentlyContinue
            
      if ( $allMatches) {
        # --- 使用 List 物件確保資料被抓取 ---
        $evtList = [System.Collections.Generic.List[string]]::new()
        
        # 逐行讀取 .evt
        $evtContent = Get-Content $evtPath
        foreach ($line in $evtContent) {
          $trimmedLine = $line.Trim()
            
          # 排除空行與星號開頭
          if ([string]::IsNullOrWhiteSpace($trimmedLine)) { continue }
            
          $cols = $trimmedLine -split '\s+'
            
          # 檢查第 7 欄 (索引 6)
          if ($cols.Count -ge 7) {
            if ($cols[6] -match $keywordPattern2) {
              $evtList.Add($trimmedLine) # 存入 List，不保留行首空白
            }
          }
        }
        # --- 新增判斷邏輯：僅處理達到門檻的檔案 ---
        if ( $evtList) {
          $summary1List.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")

          # --- 處理個別錯誤檔案 (完整結果) ---
          $debFileName = "$idPart.deb.0.5.full.txt"
          $debPath = Join-Path $fileInfo.DirectoryName $debFileName
          if ($DEBUG -eq 1 ) {
            write-host "開始處理: $($debFileName)" -ForegroundColor Gray
          }
          # 處理 .deb (全文比對)
          $debList = [System.Collections.Generic.List[string]]::new()
          if (Test-Path $debPath) {
            $debContent = Get-Content $debPath
            foreach ($line in $debContent) {
              if ([string]::IsNullOrWhiteSpace($line)) { continue }
              if ($line -match $debkeywordPattern) {
                $debList.Add($line.Trim())
              }
            }
          }
          # --- 合併與排序 ---
          $allMatches = $evtList + $debList
            
          $sortedResults = $allMatches | Sort-Object {
            # 使用正規表達式提取日期時間格式 (YY-MM-DD HH:MM:SS)
            if ($_ -match '(?<DateTime>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
              # 轉成 DateTime 物件進行精確的時間數值排序
              [DateTime]::ParseExact($Matches['DateTime'], "yy-MM-dd HH:mm:ss", $null)
            }
            else {
              # 如果該行沒有日期，排在最前面或最後面
              [DateTime]::MinValue
            }
          }

          $targetFileName = "${baseName}_${timestamp}_error.txt"
          # 完整儲存路徑：資料夾名稱 / 檔名
          $finalOutputPath = Join-Path $officeID $targetFileName

          # 將所有匹配的行內容寫入該個別檔案
          $sortedResults | Out-File -FilePath $finalOutputPath -Encoding utf8
                    

          # [新加入] 備份原始 .evt 檔
          # 目的地檔名維持原樣，但存放在 $officeID 下
          Copy-Item -Path $evtPath -Destination (Join-Path $officeID "${BaseName}_${timestamp}.txt") -Force
            
          # [新加入] 備份原始 .deb 檔 (如果存在)
          if (Test-Path $debPath) {
            $debFileInfo = Get-Item $debPath
            $debbaseName = $debFileInfo.BaseName # 不含副檔名的檔名
            Copy-Item -Path $debPath -Destination (Join-Path $officeID "${debbaseName}_${timestamp}.txt") -Force
          }
          if ($DEBUG -eq 1) {
            write-host "[成功] $officeID \ $idPart -> 檔案已儲存" -ForegroundColor Green
          }
          $logList.Add("[成功] $officeID \ $idPart -> 檔案已儲存")
        }
      }
      else {
        if ($DEBUG -eq 1) {
          write-host "[跳過] 檔案: $($evtPath) (Drive還沒失效)" -ForegroundColor Gray
        }
        $logList.Add("[跳過] 檔案: $($evtPath) (Drive還沒失效)")
      }
    }
    else {
      # 選項：可以顯示哪些檔案被忽略了
      if ($matchCount -gt 0) {
        if ($DEBUG -eq 1) {
          write-host "[跳過] 檔案: $($evtPath) (僅 $matchCount 行，未達門檻)" -ForegroundColor Gray
        }
        $logList.Add("[跳過] 檔案: $($evtPath) (僅 $matchCount 行，未達門檻)")
      }
    }
  }
}

# 3. 輸出總結報告
if ($summaryList.Count -gt 0) {
  $summaryList | Out-File -FilePath $summaryFile -Encoding utf8
  if ($summary1List.Count -gt 0) {
    $summary1List | Out-File -FilePath $summaryFile1 -Encoding utf8
    write-host "`n[完成] 總結報告已存至: $summaryFile1" -ForegroundColor Green
    write-host "[完成] 共處理了 $($summary1List.Count) 個包含錯誤的檔案。" -ForegroundColor Green
  }
}
else {
  write-host "`n未發現任何符合條件的檔案。" -ForegroundColor Yellow
}

if ($logList.Count -gt 0) {
  $logList | Out-File -FilePath $logFile -Encoding utf8
}

if ($errorlogList.Count -gt 0) {
  $errorlogList | Out-File -FilePath $errrologFile -Encoding utf8
}
pause