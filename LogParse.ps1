# Generated by Gemini
# 20260106 - first release
#Requires -Version 7.1
$DEBUG = 0
$DEV_DEBUG = 0

function Set-TicketMap($TicketMap, $QMS, $SerialNumber, $ReportTime) {
  foreach ($ticket in $TicketMap) {
    if ($ticket.QMS -eq $QMS -and $ticket.SN -eq $SerialNumber) {
      return $null
    }
  }
  return [PSCustomObject]@{
    QMS                   = $QMS
    SN                    = $SerialNumber
    reportTime            = $ReportTime
    MaxRespTime           = 0
    MaxTag                = 0
    MaxIOTimeout          = 0
    numOfFailDrv          = 0
    numOfFailDrvBeforeErr = 0
    numOfFailDrvAfterErr  = 0
    numOfFaidDrvNotFound  = 0   # a drive will be not failed but this drive had been failed in the event log
    numOfDrvNotFailed     = 0   # a drive will be failed but this drive isn't failed in the event log
    DiskList              = New-Object System.Collections.Generic.List[string]
  }
}

function Update-TicketMap($TicketMap, $Conf) {
  $TicketMap.MaxRespTime = $Conf.MaxRespTime
  $TicketMap.MaxTag = $Conf.MaxTag
  $TicketMap.MaxIOTimeout = $Conf.MaxIOTimeout
}

$SmartDetect = 0
$IOTimeout = 1
$DrvFailed = 2

# --- [強化] 自動建立磁碟對照表函式 ---
function Get-DiskMap($configPath) {
  # 讀取檔案內容
  $configContent = Get-Content -Path $configPath -Raw
  $regexResp = 'Maximum Drive Response Timeout:\s+(?<Value>\S+)'
  $respMatch = [regex]::Match($configContent, $regexResp)
  $maxRespTime = if ($respMatch.Success) { $respMatch.Groups['Value'].Value } else { "N/A" }
  $regexResp = 'Maximum Tag Count:\s+(?<Value>\S+)'
  $respMatch = [regex]::Match($configContent, $regexResp)
  $maxTag = if ($respMatch.Success) { $respMatch.Groups['Value'].Value } else { "8" }
  $regexResp = 'Disk I/O Timeout\(Sec\):\s+(?<Value>\S+)'
  $respMatch = [regex]::Match($configContent, $regexResp)
  $maxIOTimeOut = if ($respMatch.Success) { $respMatch.Groups['Value'].Value } else { "N/A" }

  $DiskList = New-Object System.Collections.Generic.List[PSCustomObject]
  #Enclosure - Slot 15
  #Slot: 1
  #$diskBlocks = $configContent -split '(?=\s+Slot(?:)\s+\d+\r?\n)'
  $diskBlocks = $configContent -split '(?=#?Slot)'
  foreach ($block in $diskBlocks) {
    # 在這一個小區塊內分別抓取欄位 (這樣就不會互相干擾)
    if ($block -match 'SCSI ID:\s+(?<ID>\d+)') {
      $id = $Matches['ID']
           
      $ldid = if ($block -match 'LD:\s+(?<LDID>[0-9A-Fa-f]+)') { $Matches['LDID'] } else { "N/A" }
      $vendor = if ($block -match 'Vender and Product ID:\s+(?<V>.*)') { $Matches['V'].Trim() } else { "N/A" }
      $rev = if ($block -match 'Revision Number:\s+(?<R>\S+)') { $Matches['R'] } else { "N/A" }
      $sn = if ($block -match 'Serial Number:\s+(?<S>\S+)') { $Matches['S'] } else { "N/A" }
      $cap = if ($block -match 'Disk Capacity \(blocks\):\s+(?<C>\d+)') { $Matches['C'] } else { 0 }

      $DiskList.Add([PSCustomObject]@{
          ID                   = [int]$id
          LDID                 = $ldid
          VendorProduct        = $vendor
          Revision             = $rev
          SerialNumber         = $sn
          SizeGB               = [Math]::Round([uint64]$cap * 512 / 1GB, 2)
          Failure              = 0
          FailureReason        = -1
          numOfBadSector       = 0
          IgnorenumOfBadSector = 0
        })
    }
  }
 
  return [PSCustomObject]@{
    MaxRespTime  = $maxRespTime
    MaxTag       = $maxTag
    MaxIOTimeout = $maxIOTimeOut
    DiskList     = $DiskList | Sort-Object ID
  }
}

function Get-DiskInMap($DisksList, $ScsiId) {
  foreach ($disk in $DisksList) {
    if ($disk.ID -eq $ScsiId) {
      return $disk
    }
  }
  return $null
}

function Set-DiskModel ($DiskModelMap, $VendorProduct) {
  #HGST    HUS726060AL5210
  $cols = $VendorProduct -split '\s+'
  $Vendor = $cols[0]
  $Model = $cols[1]
  foreach ($Disk in $DiskModelMap) {
    if ($Disk.Vendor -eq $Vendor -and $Disk.Model -eq $Model) {
      $Disk.Count++
      return $null
    }
  }
  $NewDisk = [PSCustomObject]@{
    Vendor = $Vendor
    Model  = $Model
    Count  = 1
  }
  return $NewDisk
}

function Get-OfficeID {
  param([string]$Path)
    
  if ($Path -match "[A-Za-z]+-\d+") {
    return $Matches[0]
  }
  return "XXX-Unknown"
}

function DateTime-Before ([DateTime]$Time1, [DateTime]$Time2) {
    
  if ((($Time1 - $Time2).TotalMinutes) -gt 0) {
    return -1
  }
  else {
    return 1
  }
}

function Set-LDRebuild-Time($RebuildList, $LD, $Starting, [DateTime]$Time) {
  foreach ($rebuild in $RebuildList) {
    if ($rebuild.LDID -eq $LD) {
      if ($Starting -eq 1 ) {
        if ($rebuild.EndTime -eq $null) {
          $rebuild.StartTime = $time
          return $null
        }
      }
      else {
        if ($rebuild.EndTime -eq $null -and $rebuild.StartTime -ne $null) {
          $rebuild.EndTime = $time
          return $null
        }
      }
    }
  }
  
  if ($Starting -eq 0) {
    return $null
  }
  return $rebuild = [PSCustomObject]@{
    LDID      = $LD
    StartTime = $Time
    EndTime   = $null
  }
}

function Check-LDRebuiding($RebuildList, $LD, $Time) {
  if ($Time -eq $null) {
    return 0
  }
  foreach ($rebuild in $RebuildList) {
    if ($rebuild.LDID -eq $LD) {
      if ($rebuild.EndTime -ne $null -and $rebuild.StartTime -ne $null) {
        if (($rebuild.StartTime - $Time).TotalMinutes -le 0 -and ($Time - $rebuild.EndTime).TotalMinutes -le 0) {
          return 1
        }
      }
    }
  }
  return 0
}
if (Test-Path ".\log.ps1") {
  . .\log.ps1
}
else {
  Write-Error "找不到 log.ps1，請確保檔案在同目錄。"
  return
}

if (Test-Path ".\MediaErrorPattern.ps1") {
  . .\MediaErrorPattern.ps1
}
else {
  Write-Error "找不到 MediaErrorPattern.ps1，請確保檔案在同目錄。"
  return
}

if (Test-Path ".\LogParseCfg.ps1") {
  . .\LogParseCfg.ps1
}
else {
  Write-Error "找不到 LogParseCfg.ps1，請確保檔案在同目錄。"
  return
}

write-host "開始分析檔案 (門檻：至少需包含 $minMatchCount 筆相關錯誤)..." -ForegroundColor Cyan
$AllQMSTicketDB = New-Object System.Collections.Generic.List[string]
$AnalysisQMSTicketDB = New-Object System.Collections.Generic.List[string]
# 準備存儲總結結果的清單
$summaryList = New-Object System.Collections.Generic.List[string]
$summary1List = New-Object System.Collections.Generic.List[string]
$errorlogList = New-Object System.Collections.Generic.List[string]
$logList = New-Object System.Collections.Generic.List[string]
$analysisResultList = New-Object System.Collections.Generic.List[string]
$workingReport = [System.Collections.Generic.List[PSCustomObject]]::new()
$sortingReport = [System.Collections.Generic.List[PSCustomObject]]::new()
$numOfDrvFailCase = 0
$numOfFailDrvBeforeErr = 0
$numOfFailDrvAfterErr = 0

$analysisDisks = New-Object System.Collections.Generic.List[string]

# 2. 逐一處理 Search_Report.txt 中的檔案
Get-Content $inputFile | ForEach-Object {
  $evtPath = $_.Trim()
    
  if (Test-Path $evtPath) {
    # 搜尋該檔案中「所有」匹配的行
    $MediaErr_matches = Get-MediaErrorData -logFilePath $evtPath
    $matchCount = $MediaErr_matches.Count
    $DrvFailDetected = 0
        
    if ($matchCount -ge $minMatchCount) {
      $fileInfo = Get-Item $evtPath
      $officeID = Get-OfficeID $evtPath
      $idPart = $fileInfo.Name.Split('.')[0] # 取得第一個點前面的字串
      $timestamp = $fileInfo.CreationTime.ToString("yyyyMMdd_HHmmss")
      # 建立 Disk Map, 備份 txt config file. 含硬碟資訊
      $conf = "_Conf"
      $configfileName = "$idPart$conf.txt"
      # 1. 設定檔案路徑
      $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
 
      if (-not (Test-Path $configFilePath)) {
        $configfileName = "config.txt"
        $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
        if (-not (Test-Path $configFilePath)) {
          Write-Error "找不到檔案: $configFilePath"
          $errorlogList.Add("找不到檔案: $configFilePath")
          return
        }
      }

      $thisTicket = Set-TicketMap -TicketMap $AllQMSTicketDB -QMS $officeID -SerialNumber $idPart -ReportTime $timestamp
      if ( $thisTicket -eq $null) {
        $errorlogList.Add("忽略檔案: $configFilePath, $($officeID) 已分析")
        return
      }
      Write-Host "$($evtPath)........"
      $StorageConfig = Get-DiskMap -configPath $configfilePath
      

      # 6. 建立最終的 $DiskMap (以 ID 為 Key 的 Hashtable)
      if ($StorageConfig -ne $null) {
        Update-TicketMap -TicketMap $thisTicket -Conf $StorageConfig
        $DiskMap = @{}
        foreach ($item in $StorageConfig.DiskList) {
          $DiskMap[$item.ID.ToString()] = "SCSI ID:$($item.ID) $($item.VendorProduct) REV:$($item.Revision) (SN:$($item.SerialNumber)) (Capacity:$($item.SizeGB) GB)"
        }
      }

      if ($DEBUG -eq 1 ) {
        # --- 輸出結果展示 ---
        Write-Host "已建立排序後的磁碟對照表 (共 $($StorageConfig.DiskList.Count) 筆):" -ForegroundColor Cyan
        $StorageConfig.DiskList | Format-Table -AutoSize
      }
      
      # --- 處理總結報告 (只取第一筆) ---
      $firstMatch = $MediaErr_matches[0]
      $summaryList.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")

      # --- 排序 Media error ---
      # 假設 $MediaErr_matches 是您從 Select-String 抓取出來的物件
      $sortedPatternMatchResult = Set-MediaErrorMap -MediaErrorData $MediaErr_matches

      $parsedLogsObj = Build-ParseLog -MediaErrorData $MediaErr_matches

      $finalReport = Split-MediaError-Group -LogsObj $parsedLogsObj

      $analysisReport = Do-Analysis-MediaError-Timestamp -LogsObj $parsedLogsObj

      # 最終排序：先按 ID 排，再按 Sector 數值排
      $sortedFinalReport = $finalReport | Sort-Object DriveID, SectorDec
      $sortedFinalAnalysisReport = $analysisReport | Sort-Object DriveID, StartTime


      $drvFailedMatches = Select-String -Path $evtPath -Pattern $pattern1 -ErrorAction SilentlyContinue

      # --- B. 建立 Office ID 為名的資料夾 ---
      if ( -not $drvFailedMatches) {
        $OutPutDir = "NoDrvFail\" + $officeID
        $allMatches = $MediaErr_matches
      }
      else {
        $OutPutDir = $officeID
        $allMatches = $MediaErr_matches + $drvFailedMatches;
      }
      
      if (!(Test-Path $OutPutDir)) {
        New-Item -ItemType Directory -Path $OutPutDir -Force | Out-Null
        if ($DEBUG -eq 1 ) {
          write-host "建立資料夾: $OutPutDir" -ForegroundColor Gray
        }
      } 

      $sortedDrvFailMatchResult = $allMatches | Sort-Object -Property @{
        # 1. 第一層：依據磁碟 ID 分組
        Expression = {
          if ($_.Line -match 'ID:(?<ID>\d+)') { [int64]$Matches['ID'] } else { 0 }
        }
      }, @{
        # 3. 第二層：按時間排序
        Expression = {
          if ($_.Line -match '(?<Date>\d{2}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})') {
            [DateTime]::ParseExact($Matches['Date'], "yy-MM-dd HH:mm:ss", $null)
          }
          else { [DateTime]::MinValue }
        }
      }

      Copy-Item -Path $configfilePath -Destination (Join-Path $OutPutDir "${idPart}_config_${timestamp}.txt") -Force
      # 備份 xml config file. 含硬碟資訊
      $configfileName = "$idPart$conf.xml"
      $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
      if (-not (Test-Path $configFilePath)) {
        $configfileName = "config.xml"
        $configfilePath = Join-Path $fileInfo.DirectoryName $configfileName
        if (-not (Test-Path $configFilePath)) {
          Write-Error "找不到檔案: $configFilePath"
          $errorlogList.Add("找不到檔案: $configFilePath")
        }
        else {
          Copy-Item -Path $configfilePath -Destination (Join-Path $OutPutDir "${idPart}_config_${timestamp}.xml") -Force
        }
      }

      $MediaErrorSectReportOutput = Create-MediaErrorSect-Report -Report $finalReport -DiskMap $DiskMap
      # --- 處理個別錯誤檔案 (完整結果) ---
      $debFileName = "$idPart.deb.0.5.full.txt"
      $debPath = Join-Path $fileInfo.DirectoryName $debFileName
      # 處理 .deb (全文比對)
      $debList = [System.Collections.Generic.List[string]]::new()
      if (Test-Path $debPath) {
        $debContent = Get-Content $debPath
        foreach ($line in $debContent) {
          if ([string]::IsNullOrWhiteSpace($line)) { continue }
          if ($line -match $debkeywordPattern) {
            $debList.Add($line.Trim())
          }
        }
      }


      # Drive failure detection
      $drvErrMatches = Select-String -Path $evtPath -Pattern $DrvErrPattern -ErrorAction SilentlyContinue
      $rebuildMatches = Select-String -Path $evtPath -Pattern $RebuildPattern -ErrorAction SilentlyContinue
      $RebuildSeq = [System.Collections.Generic.List[string]]::new()
      $rebuildMatches | ForEach-Object {
        if ($_ -match '(?<DateTime>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
          # 轉成 DateTime 物件進行精確的時間數值排序
          $foundTime = [DateTime]::ParseExact($Matches['DateTime'], "yy-MM-dd HH:mm:ss", $null)
                
          if ($_.Line -match $keywordRebuildStartPattern) {
            $LDID = $Matches['LD']
            $rebuild = Set-LDRebuild-Time -RebuildList $RebuildSeq -LD $LDID -Starting 1 -Time $foundTime
            if ($rebuild -ne $null) {
              $RebuildSeq += $rebuild
            }
          }
          else {
            if ($_.Line -match $keywordRebuildCmpltPattern) {
              $LDID = $Matches['LD']
              Set-LDRebuild-Time -RebuildList $RebuildSeq -LD $LDID -Starting 0 -Time $foundTime
            }
          }
        }
      }
            
      # $debList - from *.deb.0.5.full.txt, events we needs
      # $drvErrMatches - from *.evt.0.5.full.txt, Events we needs
      # $sortedFinalAnalysisReport - sorted by Drive ID and time
      $ScsiId = -1
      $BadSector = 0
      $DriveIsFailed = 0
      $numOfDrvFail = 0
      $numOfDrvFailButNotFound = 0
      $numOfDrvFailBeforeErrInThisQMS = 0
      $numOfDrvFailAfterErrInThisQMS = 0
      $DrvFailBeforeTmout = -1
      $DrvFailBeforeErr = -1
      $numOfAnalysisDrv = 0
      $lastTime = $null
      $FailureDrvList = New-Object System.Collections.Generic.List[string]
      if ([int]$StorageConfig.maxTag -gt 8) {
        #$MaxNumOfBadSectors = $DefMaxNumOfBadSector * 3 + 2
        $MaxNumOfBadSectors = [int]$StorageConfig.maxTag + 1
      }
      else {
        $MaxNumOfBadSectors = $DefMaxNumOfBadSector
      }
      $CurrDisk = $null
      $workingReport.Clear()
      $sortedFinalAnalysisReport | ForEach-Object {
        if ($_.DriveID -ne $null) {
          if ($DEBUG -eq 1) {
            write-host "ID: $($_.DriveID) GB: $($_.StartGB) $($_.StartTime) $($_.ErrorCount)" -ForegroundColor Gray
          }
          if ($ScsiId -eq -1) {
            $ScsiId = $_.DriveID
            $CurrDisk = Get-DiskInMap -DisksList $StorageConfig.DiskList -ScsiId $ScsiId
            if ($CurrDisk -ne $null) {
              Add-SectorToList -List $workingReport -DriveID $_.DriveID -GBZone $_.StartGB -Time $_.StartTime
              $LDID = $CurrDisk.LDID
              $lastTime = $_.StartTime
              $rebuilding = Check-LDRebuiding -RebuildList $RebuildSeq -LD $LDID -Time $lastTime
              if ($rebuilding -eq 1) {
                #$BadSector = 0
                $CurrDisk.IgnorenumOfBadSector++
              }
              else {
                #$BadSector = 1
              }
            }
            else {
              $errorlogList.Add("找不到 SCSI ID:$($ScsiId)。")
              $ScsiId = -1
            }
          }
          else {
            if ($_.DriveID -ne $ScsiId) {
              if ($DEV_DEBUG -eq 1) {
                write-host("SCSI ID: $($ScsiId)")
                write-host("BadSector=$($BadSector), workreport.count=$($workingReport.Count)")
                write-host("Go to next SCSI ID: $($_.DriveID)")
              }
              # parse current disk
              if ($BadSector -le $MaxNumOfBadSectors -and $BadSector -gt $DefMinNumOfBadSector -and $DriveIsFailed -eq 0) {
                if ($CurrDisk -ne $null) {
                  if ($CurrDisk.ID -ne $ScsiId) {
                    $errorlogList.Add("SCSI ID $($CurrDisk.ID) 和目前使用的 ID $($ScsiId) 不同。")
                  }
                  $CurrDisk.numOfBadSector = $BadSector
                  $thisTicket.DiskList += $CurrDisk
                }
                else {
                  $errorlogList.Add("找不到 SCSI ID:$($ScsiId)。")
                }
              }
              else {
                if ($BadSector -ne 0) {
                  $CurrDisk.numOfBadSector = $workingReport.Count
                }
                $DriveIsFailed = 0
              }
              $ScsiId = $_.DriveID
              $CurrDisk = Get-DiskInMap -DisksList $StorageConfig.DiskList -ScsiId $ScsiId
              if ($CurrDisk -ne $null) {
                $workingReport.Clear()
                #$BadSector = 0
                Add-SectorToList -List $workingReport -DriveID $_.DriveID -GBZone $_.StartGB -Time $_.StartTime
                $LDID = $CurrDisk.LDID
                $lastTime = $_.StartTime
                $BadSector = $workingReport.Count
              }
              else {
                $errorlogList.Add("找不到 SCSI ID:$($ScsiId)。")
                $ScsiId = -1
              }
            }
            $rebuilding = Check-LDRebuiding -RebuildList $RebuildSeq -LD $LDID -Time $_.StartTime
            if ($rebuilding -eq 0) {
              if ($ScsiId -eq $_.DriveID) {
                $currItem = $_
                if ($DriveIsFailed -eq 0 -and [Math]::Abs(($_.StartTime - $lastTime).TotalDays) -gt $WeekThresholdDays) {
                  $sortingReport.Clear()
                  foreach ($item in $workingReport) {
                    if ($currItem.DriveID -ne $item.DriveID) {
                      Write-Error("SCSI ID $($currItem.DriveID) 和目前使用的 ID $($item.DriveID) 不同。")
                      pause
                    }
                    if ($currItem.StartGB -ne $item.StartGB) {
                      if ([Math]::Abs(($currItem.StartTime - $item.StartTime).TotalDays) -le $WeekThresholdDays) {
                        $null = Add-SectorToList -List $sortingReport -DriveID ($item.DriveID) -GBZone ($item.StartGB) -Time ($item.StartTime)
                        if ($sortingReport.Count -eq 1) {
                          $lastTime = $item.StartTime
                        }
                      }
                    }
                  }
                  $workingReport.Clear()
                  foreach ($item in $sortingReport) {
                    $workingReport.Add($item.PSObject.Copy())
                  }
                  Add-SectorToList -List $workingReport -DriveID $currItem.DriveID -GBZone $currItem.StartGB -Time $currItem.StartTime

                  if ($workingReport.Count -eq 1) {
                    $lastTime = $currItem.StartTime
                  }
                  $BadSector = $workingReport.Count
                }
                else {
                  if ($DriveIsFailed -eq 0) {
                    $sortingReport.Clear()
                    foreach ($item in $workingReport) {
                      if ($currItem.DriveID -ne $item.DriveID) {
                        Write-Error("SCSI ID $($currItem.DriveID) 和目前使用的 ID $($item.DriveID) 不同。")
                        pause
                      }
                      if ($currItem.StartGB -ne $item.StartGB) {
                        $null = Add-SectorToList -List $sortingReport -DriveID ($item.DriveID) -GBZone ($item.StartGB) -Time ($item.StartTime)
                        if ($sortingReport.Count -eq 1) {
                          $lastTime = $item.StartTime
                        }
                      }
                    }
                    $workingReport.Clear()
                    foreach ($item in $sortingReport) {
                      $workingReport.Add($item.PSObject.Copy())
                    }
                    if ($workingReport.Count -eq 1) {
                      $lastTime = $currItem.StartTime
                    }
                    Add-SectorToList -List $workingReport -DriveID $currItem.DriveID -GBZone $currItem.StartGB -Time $currItem.StartTime
                  }
                  else {
                    $dupSector = 0
                    if ($DEV_DEBUG -eq 1) {
                      write-host("SCSI ID: $($ScsiId) was failed, workreport.count=$($workingReport.Count)")
                    }
                    foreach ($item in $workingReport) {
                      if ($currItem.DriveID -ne $item.DriveID) {
                        Write-Error("SCSI ID $($currItem.DriveID) 和目前使用的 ID $($item.DriveID) 不同。")
                        pause
                      }
                      if ($currItem.StartGB -eq $item.StartGB) {
                        $dupSector = 1
                        break;
                      }
                    }
                  }
                  if ($dupSector -eq 0) {
                    if ($DEV_DEBUG -eq 1) {
                      write-host("SCSI ID: $($ScsiId) was failed, Add new item, $($currItem.StartGB)")
                    }
                    Add-SectorToList -List $workingReport -DriveID $currItem.DriveID -GBZone $currItem.StartGB -Time $currItem.StartTime
                  }
                  $BadSector = $workingReport.Count
                }
              }
              else {
                if ($DEV_DEBUG -eq 1) {
                  write-host("SCSI ID: $($ScsiId)")
                  write-host("BadSector=$($BadSector), workreport.count=$($workingReport.Count)")
                  write-host("Go to next SCSI ID: $($_.DriveID)")
                }
                if ($BadSector -le $MaxNumOfBadSectors -and $BadSector -gt $DefMinNumOfBadSector -and $DriveIsFailed -eq 0) {
                  foreach ($drvEvent in $drvErrMatches) {
                    if ($drvEvent.Line -match 'CH(?:L)?[:\s]+(?<Channel>\d+)\s+ID:(?<ID>\d+)') {
                      $foundID = [int64]$Matches['ID']
                      if ($foundID -eq $ScsiId) {
                        if ($numOfDrvFail -eq 0) {
                          Write-Ticket-Title -LogList $analysisResultList -Qms $officeID -SerialNumber $idPart -StorageConf $StorageConfig
                        }
                        $numOfDrvFail++
                        $numOfDrvFailCase++
                        $numOfDrvFailButNotFound++
                        $analysisResultList.Add("")
                        $currentVendor = $DiskMap[$ScsiId.ToString()]
                        if ($currentVendor) {
                          $analysisResultList.Add("    $($currentVendor)");
                          $FailureDrvList += $currentVendor
                        }
                        if ($CurrDisk -ne $null) {
                          $DiskModel = Set-DiskModel -DiskModelMap $analysisDisks -VendorProduct $CurrDisk.VendorProduct
                          if ( $DiskModel -ne $null) {
                            $analysisDisks += $DiskModel
                          }
                          $CurrDisk.Failure = 2     # failure but not found
                          $CurrDisk.numOfBadSector = $BadSector
                          $CurrDisk.FailureReason = $IOTimeout
                          $thisTicket.DiskList += $CurrDisk
                        }
                        $analysisResultList.Add($drvEvent.Line)
                        $logList.Add($drvEvent.Line)
                        break
                      }
                    }
                  }
                }
                #$BadSector = 1
                $ScsiId = $_.DriveID
                $CurrDisk = Get-DiskInMap -DisksList $StorageConfig.DiskList -ScsiId $ScsiId
                if ($CurrDisk -ne $null) {
                  $LDID = $CurrDisk.LDID
                  $lastTime = $_.StartTime
                  $DriveIsFailed = 0
                }
                else {
                  $ScsiId = -1
                }
              }
            }
            else {
              $CurrDisk.IgnorenumOfBadSector++
            }
            if ($DEV_DEBUG -eq 1 -and $DriveIsFailed -eq 0) {
              write-host("BadSector=$($BadSector), workreport.count=$($workingReport.Count) Failed=$($DriveIsFailed)")
            }
            if ($BadSector -gt $MaxNumOfBadSectors -and $DriveIsFailed -eq 0) {
              if ($numOfDrvFail -eq 0) {
                Write-Ticket-Title -LogList $analysisResultList -Qms $officeID -SerialNumber $idPart -StorageConf $StorageConfig
              }
              $numOfDrvFail++
              $numOfDrvFailCase++
              $analysisResultList.Add("")
              $currentVendor = $DiskMap[$ScsiId.ToString()]
              if ($currentVendor) {
                $analysisResultList.Add("    $($currentVendor)");
                $FailureDrvList += $currentVendor
              }
              if ($CurrDisk -ne $null) {
                $CurrDisk.numOfBadSector = $BadSector
                $CurrDisk.Failure = 1
                $DiskModel = Set-DiskModel -DiskModelMap $analysisDisks -VendorProduct $CurrDisk.VendorProduct
                if ( $DiskModel -ne $null) {
                  $analysisDisks += $DiskModel
                }
                $thisTicket.DiskList += $CurrDisk
              }
              else {
                $errorlogList.Add("找不到 SCSI ID:$($ScsiId)。")
              }

              $logList.Add("           $($_.StartTime | Get-Date -Format "yy-MM-dd HH-mm-ss") ID:$($ScsiId)     Drive Failure")
              $analysisResultList.Add("           $($_.StartTime | Get-Date -Format "yy-MM-dd HH-mm-ss") ID:$($ScsiId)     Drive Failure")
              $DriveIsFailed = 1
              $DrvFailDetected = 1
              $FailAlogDetected = 0
              $DrvFailBeforeTmout = -1
              $DrvFailBeforeErr = -1
              $EventTime = $_.StartTime
              $debList | ForEach-Object {
                if ($DrvFailBeforeTmout -le 0) {
                  $foundID = -1
                  if ($_ -match 'M62: Chl (?<CHL>\d+) Id (?<ID>[0-9a-fA-F]+)') {    
                    $foundID = [Convert]::ToInt64($Matches['ID'], 16)
                  }
                  else {
                    #Drive ChlNo:8 ID:276 High latency detected(op: 0, last request latency:767ms, request amount:65535 
                    if ($_ -match 'Drive ChlNo:(?<CHL>\d+) ID:(?<ID>\d+)') {
                      $foundID = [Convert]::ToInt64($Matches['ID'])
                      if ($foundID -eq $ScsiId) {
                        $logList.Add("$($_), target id $($ScsiId), foundId $($foundId)")
                      }
                    }
                    else {
                      # Drive Channel - Chl(8) Id(122) Device is missing, Reason(8h)
                      if ($_ -match 'Drive Channel - Chl\((?<CHL>\d+)\) Id\((?<ID>\d+)\)') {
                        $foundID = [Convert]::ToInt64($Matches['ID'])
                        if ($foundID -eq $ScsiId) {
                          $logList.Add("$($_), target id $($ScsiId), foundId $($foundId)")
                        }
                      }
                    }
                  }
                  if ($foundID -eq $ScsiId) {
                    if ($FailAlogDetected -eq 0 -and $_ -match '(?<DateTime>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
                      # 轉成 DateTime 物件進行精確的時間數值排序
                      $foundTime = [DateTime]::ParseExact($Matches['DateTime'], "yy-MM-dd HH:mm:ss", $null)
                      if ($foundTime -ne $null) {
                        if (($EventTime - $foundTime).TotalMinutes -le 0) {
                          if ($DrvFailBeforeTmout -lt 0) {
                            $DrvFailBeforeTmout = 1
                          }
                          $FailAlogDetected = 1
                          $analysisResultList.Add($_)
                          $logList.Add($_)
                        }
                        else {
                          $DrvFailBeforeTmout = 0
                          $analysisResultList.Add($_)
                          $logList.Add($_)
                        }
                      }
                    }
                  }
                }
              }
              $FailAlogDetected = 0
              $drvErrMatches | ForEach-Object {
                if ($_.Line -match 'CH(?:L)?[:\s]+(?<Channel>\d+)\s+ID:(?<ID>\d+)') {
                  $foundID = [int64]$Matches['ID']
                  if ($foundID -eq $ScsiId) {
                    if ($FailAlogDetected -eq 0 -and $_.Line -match '(?<Date>\d{2}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})') {
                      $foundTime = [DateTime]::ParseExact($Matches['Date'], "yy-MM-dd HH:mm:ss", $null)
                      if ($foundTime -ne $null) {
                        if (($EventTime - $foundTime).TotalMinutes -le 0) {
                          if ($DrvFailBeforeErr -lt 0) {
                            $DrvFailBeforeErr = 1
                          }
                          $FailAlogDetected = 1
                          $analysisResultList.Add($_.Line)
                          $logList.Add($_.Line)
                        }
                        else {
                          $DrvFailBeforeErr = 0
                          $analysisResultList.Add($_.Line)
                          $logList.Add($_.Line)
                        }
                      }
                    }
                  }
                }
              }

              if ($DrvFailBeforeErr -ge 0 -or $DrvFailBeforeTmout -ge 0) {
                if ($DrvFailBeforeErr -eq 0 -or $DrvFailBeforeTmout -eq 0) {
                  $numOfFailDrvAfterErr++
                  $numOfDrvFailAfterErrInThisQMS++
                  $CurrDisk.FailureReason = $DrvFailed
                }
                else {
                  $numOfFailDrvBeforeErr++
                  $numOfDrvFailBeforeErrInThisQMS++
                  $CurrDisk.FailureReason = $IOTimeout
                }
              }
            }
            else {
              #if($DriveIsFailed -eq 1)
              #{
              #    if($CurrDisk -ne $null)
              #    {
              #        $CurrDisk.numOfBadSector++
              #    }
              #}
            }
          }
        }
      }

      if ($BadSector -le $MaxNumOfBadSectors -and $BadSector -gt $DefMinNumOfBadSector -and $DriveIsFailed -eq 0) {
        $CurrDisk = Get-DiskInMap -DisksList $StorageConfig.DiskList -ScsiId $ScsiId
        if ($CurrDisk -ne $null) {
          $BreakInLoop = 0
          foreach ($drvEvent in $drvErrMatches) {
            if ($drvEvent.Line -match 'CH(?:L)?[:\s]+(?<Channel>\d+)\s+ID:(?<ID>\d+)') {
              $foundID = [int64]$Matches['ID']
              if ($foundID -eq $ScsiId) {
                if ($numOfDrvFail -eq 0) {
                  Write-Ticket-Title -LogList $analysisResultList -Qms $officeID -SerialNumber $idPart -StorageConf $StorageConfig
                }
                $numOfDrvFail++
                $numOfDrvFailButNotFound++
                $numOfDrvFailCase++
                $analysisResultList.Add("")
                $currentVendor = $DiskMap[$ScsiId.ToString()]
                if ($currentVendor) {
                  $analysisResultList.Add("    $($currentVendor)");
                  $FailureDrvList += $currentVendor
                }
                $DiskModel = Set-DiskModel -DiskModelMap $analysisDisks -VendorProduct $CurrDisk.VendorProduct
                if ( $DiskModel -ne $null) {
                  $analysisDisks += $DiskModel
                }
                $CurrDisk.numOfBadSector = $BadSector
                $CurrDisk.Failure = 2
                $CurrDisk.FailureReason = $IOTimeout
                $thisTicket.DiskList += $CurrDisk
              }
              $analysisResultList.Add($drvEvent.Line)
              $logList.Add($drvEvent.Line)
              $BreakInLoop = 1
              break
            }
          }
          if ( $BreakInLoop -eq 0) {
            $CurrDisk.numOfBadSector = $BadSector
            $thisTicket.DiskList += $CurrDisk
            $numOfAnalysisDrv++
          }
        }
        else {
          $errorlogList.Add("找不到 SCSI ID:$($ScsiId)。")
        }
      }
      else {
        if ($CurrDisk -ne $null) {
          $CurrDisk.numOfBadSector = $BadSector
        }
      }
      if ($numOfDrvFail -gt 0) {
        $analysisResultList.Add("     number of the failure drives: $($numOfDrvFail)")
        $analysisResultList.Add("     number of before error : $($numOfDrvFailBeforeErrInThisQMS)")
        $analysisResultList.Add("     number of after error: $($numOfDrvFailAfterErrInThisQMS)")
        $analysisResultList.Add("     number of not found: $($numOfDrvFailButNotFound)")
        $NumOfNeedToCheck = $numOfDrvFail - ($numOfDrvFailBeforeErrInThisQMS + $numOfDrvFailAfterErrInThisQMS + $numOfDrvFailButNotFound)
        if ($NumOfNeedToCheck -gt 0) {
          $analysisResultList.Add("     number of need to check: $($NumOfNeedToCheck)")
        }
        $analysisResultList.Add("-----------------------------------------------------------------------------------")
        $analysisResultList.Add("")
        $thisTicket.numOfFailDrv = $numOfDrvFail
        $thisTicket.numOfFailDrvBeforeErr = $numOfDrvFailBeforeErrInThisQMS
        $thisTicket.numOfFailDrvAfterErr = $numOfDrvFailAfterErrInThisQMS
        $thisTicket.numOfFaidDrvNotFound = $numOfDrvFailButNotFound
        $thisTicket.numOfDrvNotFailed = $NumOfNeedToCheck
        $AllQMSTicketDB += $thisTicket
      }
      else {
        if ( $numOfAnalysisDrv -gt 0) {
          $AnalysisQMSTicketDB += $thisTicket
        }
      }

      # Starting backup the result
      $baseName = $fileInfo.BaseName # 不含副檔名的檔名


      $patternMatchOutPath = Join-Path $OutPutDir "${baseName}_${timestamp}_mediaerror.txt"

      # 儲存與輸出至 xxx_mediaerror.txt
      $MediaErrorSectReportOutput | Out-File -FilePath $patternMatchOutPath -Encoding UTF8
      $sortedFinalReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | Format-Table -AutoSize |
      Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      $sortedFinalAnalysisReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | Format-Table -AutoSize |
      Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      $sortedDrvFailMatchResult.Line  | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8

      # 儲存與輸出至 xxx_mediaerror_sorted.txt
      $patternMatchOutPath = Join-Path $OutPutDir "${baseName}_${timestamp}_mediaerror_sorted.txt"
      $MediaErrorSectReportOutput | Out-File -FilePath $patternMatchOutPath -Encoding UTF8
      $sortedPatternMatchResult.Line | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      $StorageConfig.MaxRespTime | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      $StorageConfig.DiskList | Format-Table -AutoSize | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8
      # 定義檔名
      $csvFileName = "Disk_Error_Report_${baseName}_${timestamp}.csv"
      $csvFilePath = Join-Path $OutPutDir $csvFileName

      # 將結果選取需要的欄位並匯出
      $sortedFinalReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | 
      Export-Csv -Path $csvFilePath -NoTypeInformation -Encoding UTF8

      if ($DEBUG -eq 1) {
        Write-Host "Excel 報表已儲存至: $csvFileName" -ForegroundColor Green
      }
            
      if ( $drvFailedMatches) {
        # --- 使用 List 物件確保資料被抓取 ---
        $evtList = [System.Collections.Generic.List[string]]::new()
        
        # 逐行讀取 .evt
        $evtContent = Get-Content $evtPath
        foreach ($line in $evtContent) {
          $trimmedLine = $line.Trim()
            
          # 排除空行與星號開頭
          if ([string]::IsNullOrWhiteSpace($trimmedLine)) { continue }
            
          $cols = $trimmedLine -split '\s+'
            
          # 檢查第 7 欄 (索引 6)
          if ($cols.Count -ge 7) {
            if ($cols[6] -match $keywordPattern2) {
              $evtList.Add($trimmedLine) # 存入 List，不保留行首空白
            }
          }
        }
        # --- 新增判斷邏輯：僅處理達到門檻的檔案 ---
        if ( $evtList) {
          $summary1List.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")

          # --- 合併與排序 ---
          $allMatches = $evtList + $debList
            
          $sortedResults = $allMatches | Sort-Object {
            # 使用正規表達式提取日期時間格式 (YY-MM-DD HH:MM:SS)
            if ($_ -match '(?<DateTime>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
              # 轉成 DateTime 物件進行精確的時間數值排序
              [DateTime]::ParseExact($Matches['DateTime'], "yy-MM-dd HH:mm:ss", $null)
            }
            else {
              # 如果該行沒有日期，排在最前面或最後面
              [DateTime]::MinValue
            }
          }

          $targetFileName = "${baseName}_${timestamp}_error.txt"
          # 完整儲存路徑：資料夾名稱 / 檔名
          $finalOutputPath = Join-Path $OutPutDir $targetFileName
          # 3. 儲存與輸出
          $MediaErrorSectReportOutput | Out-File -FilePath $finalOutputPath -Encoding UTF8
          # 將所有匹配的行內容寫入該個別檔案
          $sortedResults | Out-File -FilePath $finalOutputPath -Append -Encoding utf8
                    
          
          # 備份原始 .evt 檔
          # 目的地檔名維持原樣，但存放在 $OutPutDir 下
          Backup-Log-Files -FileInfo $fileInfo -SerialNumber $idPart -BaseName $baseName -TimeStamp $timestamp -OutPutDir $OutPutDir
          if ($DEBUG -eq 1) {
            write-host "[成功] $officeID \ $idPart -> 檔案已儲存" -ForegroundColor Green
          }
          $logList.Add("[成功] $officeID \ $idPart -> 檔案已儲存")
        }
      }
      else {
        if ($DEBUG -eq 1) {
          write-host "[跳過] 檔案: $($evtPath) (Drive還沒失效)" -ForegroundColor Gray
        }
        $logList.Add("[跳過] 檔案: $($evtPath) (Drive還沒失效)")
        if ($DrvFailDetected -eq 1) {
          $analysisResultList.Add("[跳過] 檔案: $($evtPath) (Drive還沒失效)")
        }
        Backup-Log-Files -FileInfo $fileInfo -SerialNumber $idPart -BaseName $baseName -TimeStamp $timestamp -OutPutDir $OutPutDir
      }
    }
    else {
      # 選項：可以顯示哪些檔案被忽略了
      if ($matchCount -gt 0) {
        if ($DEBUG -eq 1) {
          write-host "[跳過] 檔案: $($evtPath) (僅 $matchCount 筆，未達門檻)" -ForegroundColor Gray
        }
        $logList.Add("[跳過] 檔案: $($evtPath) (僅 $matchCount 筆，未達門檻)")
      }
    }
  }
}

# 3. 輸出總結報告
if ($summaryList.Count -gt 0) {
  $summaryList | Out-File -FilePath $resultFile -Encoding utf8
  if ($summary1List.Count -gt 0) {
    $summary1List | Out-File -FilePath $resultFile1 -Encoding utf8
    write-host "`n[完成] 總結報告已存至: $summaryFile1" -ForegroundColor Green
    write-host "[完成] 共處理了 $($summary1List.Count) 個包含錯誤的檔案。" -ForegroundColor Green
  }
}
else {
  write-host "`n未發現任何符合條件的檔案。" -ForegroundColor Yellow
}

if ($logList.Count -gt 0) {
  $logList | Out-File -FilePath $logFile -Encoding utf8
}

if ($errorlogList.Count -gt 0) {
  $errorlogList | Out-File -FilePath $errrologFile -Encoding utf8
}

if ($analysisResultList.Count -gt 0) {
  $summaryList = New-Object System.Collections.Generic.List[string]
  $analysisResultList.Add("Total case: $($numOfDrvFailCase), Failed Drive before errors: $($numOfFailDrvBeforeErr), Failed Drive after errors: $($numOfFailDrvAfterErr)")
  $analysisFileTxt = $analysisFile + ".txt"
  $analysisResultList | Out-File -FilePath $analysisFileTxt -Encoding utf8
  $numOfQMS = $AllQMSTicketDB.Count
  $numOfDisk = 0
  $numOfBefore = 0
  $numOfAfter = 0
  $numOfFaidDrvNotFound = 0
  $numOfDrvNotFailed = 0
  $summaryList.Add("============================================================")
  $summaryList.Add("QMS        SN     numOfFailDrv numOfFailDrvBeforeErr numOfFailDrvAfterErr numOfFaidDrvNotFound     numOfDrvNotFailed")
  $summaryList.Add("---        --     ------------ --------------------- -------------------- --------------------")
  # Ticket summary
  foreach ($ticket in $AllQMSTicketDB) {
    $summaryList.Add("$($ticket.QMS) $($ticket.SN)        $($ticket.numOfFailDrv)               $($ticket.numOfFailDrvBeforeErr)                $($ticket.numOfFailDrvAfterErr)                           $($ticket.numOfFaidDrvNotFound)                 $($ticket.numOfDrvNotFailed)")
    foreach ($disk in $ticket.DiskList) {
      $summaryList.Add("   | $($disk)")
    }
    $numOfDisk += $ticket.numOfFailDrv
    $numOfBefore += $ticket.numOfFailDrvBeforeErr
    $numOfAfter += $ticket.numOfFailDrvAfterErr
    $numOfFaidDrvNotFound += $ticket.numOfFaidDrvNotFound
    $numOfDrvNotFailed += $ticket.numOfDrvNotFailed
  }
  #$numOfDrvNotFailed = $numOfDisk - $numOfBefore - $numOfAfter - $numOfFaidDrvNotFound
  $summaryList.Add("---        --     ------------ --------------------- --------------------")
  $summaryList.Add("     $($numOfQMS)                    $($numOfDisk)               $($numOfBefore)                $($numOfAfter)                           $($numOfFaidDrvNotFound)                        $($numOfDrvNotFailed)")
  $summaryFileTxt = $summaryFile + ".txt"
  $summaryList | Out-File -FilePath $summaryFileTxt -Encoding utf8
  $summaryFileTxt = $summaryFile + "1.txt"
  $AllQMSTicketDB | Format-Table -AutoSize | Out-File -FilePath $summaryFileTxt -Encoding utf8
  if ($analysisDisks.Count -gt 0) {
    $analysisDisks | Format-Table -AutoSize | Out-File -FilePath $summaryFileTxt -Append -Encoding utf8
  }
  $summaryFileCSV = $summaryFile + ".csv"
  Write-Ticket-Summary -cvsFilePath $summaryFileCSV -QmsDB $AllQMSTicketDB
  $summaryFileCSV = $summaryFile + "_unfailure.csv"
  Write-Ticket-Summary -cvsFilePath $summaryFileCSV -QmsDB $AnalysisQMSTicketDB
}

write-host "Total case: $($numOfDrvFailCase), Failed Drive before errors: $($numOfFailDrvBeforeErr), Failed Drive after errors: $($numOfFailDrvAfterErr),  Drive Failure but not fould: $($numOfFaidDrvNotFound)"
pause