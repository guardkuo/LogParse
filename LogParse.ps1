# Generated by Gemini
# 20260106 - first release

# EVENT ID
#220A0148: Drive fail
#220A0188: Drive Failure
#020AA182: clone
#320A4509: LD fatal
#12084204: Drive Event Detected-Starting Clone

#220A0749: Media Scan Failed
#22084202: No availible drive for cloning
#22084285: Drive Event Detected-Clone Failed
#22080581: Timeout Waiting for I/O to Complete
#21080282: Gross Phase/Signal Error Detected
#020A8305: Rebuild
#22081882

# 1. 設定關鍵字與檔案路徑
# media error
$keywords = @("02081382", "02081342", "02081341", "02081381")
# drive fail, rebuild, clone, io error
$keywords1 = @("21081282", "220A0188", "220A0187", "220A0185", "220A0148", "12084204")

# events we want
$keywords2 = @("02081382", "02081342", "02081341", "02081381", "21081282", "220A0188", "22080581", "020A8305", "020AA182", "320A4509", "220A0187", "22084205", "22084202", "020A8402", "21080282", "22080181", "220A1182", "12084243", "12084244", "020AA142", "020AA281", "220A0185", "12084204", "22080541", "22080542", "220A0148", "21080242", "22080141", "02081781", "22084285", "12084284", "220A0749", "22081882")

$debkeywords = @("M62:", "High latency detected")
$inputFile = "Search_Report_EU.txt"
$summaryFile = "Column7_Match_Result_EU.txt"
$summaryFile1 = "Column7_Match_Result1_EU.txt"
$minMatchCount = 20  # 設定門檻：少於 20 行則忽略

# 建立搜尋正則：鎖定第七欄
$keywordPattern = ($keywords | ForEach-Object { [regex]::Escape($_) }) -join '|'
$pattern = "^\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+($keywordPattern)"

$keywordPattern1 = ($keywords1 | ForEach-Object { [regex]::Escape($_) }) -join '|'
$pattern1 = "^\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+($keywordPattern1)"

$keywordPattern2 = ($keywords2 | ForEach-Object { [regex]::Escape($_) }) -join '|'
$pattern2 = "^\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+($keywordPattern2)"

$debkeywordPattern = ($debkeywords | ForEach-Object { [regex]::Escape($_) }) -join '|'

# 定義 1GB 所佔用的 Sector 數量 (以 512-byte sector 為例)
$SectorsPerGB = 2097152

write-host "開始分析檔案 (門檻：至少需包含 $minMatchCount 行匹配內容)..." -ForegroundColor Cyan

# 準備存儲總結結果的清單
$summaryList = New-Object System.Collections.Generic.List[string]
$summary1List = New-Object System.Collections.Generic.List[string]

# 2. 逐一處理 Search_Report.txt 中的檔案
Get-Content $inputFile | ForEach-Object {
  $evtPath = $_.Trim()
    
  if (Test-Path $evtPath) {
    # 搜尋該檔案中「所有」匹配的行
    $Pattern_matches = Select-String -Path $evtPath -Pattern $pattern -ErrorAction SilentlyContinue
    $matchCount = $Pattern_matches.Count
        
    if ($matchCount -ge $minMatchCount) {
      # --- 處理總結報告 (只取第一筆) ---
      $firstMatch = $Pattern_matches[0]
      $summaryList.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")

      # --- 排序 Media error ---
      # 假設 $Pattern_matches 是您從 Select-String 抓取出來的物件
      $sortedPatternMatchResult = $Pattern_matches | Sort-Object -Property @{
        # 1. 第一層：依據磁碟 ID 分組
        Expression = {
          if ($_.Line -match 'ID:(?<ID>\d+)') { [int64]$Matches['ID'] } else { 0 }
        }
      }, @{
        # 2. 第二層：1GB 區域對齊 (Grouping by GB range)
        Expression = {
          if ($_.Line -match '0x(?<Sector>[0-9A-Fa-f]+)') {
            $decSector = [Convert]::ToInt64($Matches['Sector'], 16)
            # 將 Sector 除以 1GB 的總數並取整數，得到「第幾個 GB」
            [Math]::Floor($decSector / $SectorsPerGB)
          }
          else { 0 }
        }
      }, @{
        # 3. 第三層：在同一個 1GB 區域內，按時間排序
        Expression = {
          if ($_.Line -match '(?<Date>\d{2}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})') {
            [DateTime]::ParseExact($Matches['Date'], "yy-MM-dd HH:mm:ss", $null)
          }
          else { [DateTime]::MinValue }
        }
      }
      $fileInfo = Get-Item $evtPath
      # --- A. 提取路徑中的 Office ID (例如 OFY-508427) ---
      $pathParts = $evtPath -split '\\'
      $officeID = if ($pathParts.Count -ge 6) { $pathParts[5] } else { "Unknown" }
      # --- B. 建立 Office ID 為名的資料夾 ---
      if (!(Test-Path $officeID)) {
        New-Item -ItemType Directory -Path $officeID -Force | Out-Null
        write-host "建立資料夾: $officeID" -ForegroundColor Gray
      }
      $baseName = $fileInfo.BaseName # 不含副檔名的檔名
      $timestamp = $fileInfo.CreationTime.ToString("yyyyMMdd_HHmmss")
      $patternMatchFileName = "${baseName}_${timestamp}_mediaerror.txt"
      $patternMatchOutPath = Join-Path $officeID $patternMatchFileName
      $Pattern_matches.Line | Out-File -FilePath $patternMatchOutPath -Encoding utf8

      $patternMatchFileName = "${baseName}_${timestamp}_mediaerror_sorted.txt"
      $patternMatchOutPath = Join-Path $officeID $patternMatchFileName
      $sortedPatternMatchResult.Line | Out-File -FilePath $patternMatchOutPath -Encoding utf8

      $allMatches = Select-String -Path $evtPath -Pattern $pattern1 -List -ErrorAction SilentlyContinue
            
      if ( $allMatches) {
        # --- 使用 List 物件確保資料被抓取 ---
        $evtList = [System.Collections.Generic.List[string]]::new()
        
        # 逐行讀取 .evt
        $evtContent = Get-Content $evtPath
        foreach ($line in $evtContent) {
          $trimmedLine = $line.Trim()
            
          # 排除空行與星號開頭
          if ([string]::IsNullOrWhiteSpace($trimmedLine)) { continue }
            
          $cols = $trimmedLine -split '\s+'
            
          # 檢查第 7 欄 (索引 6)
          if ($cols.Count -ge 7) {
            if ($cols[6] -match $keywordPattern2) {
              $evtList.Add($trimmedLine) # 存入 List，不保留行首空白
            }
          }
        }
        # --- 新增判斷邏輯：僅處理達到門檻的檔案 ---
        if ( $evtList) {
          $summary1List.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")
          # --- 處理個別錯誤檔案 (完整結果) ---
          $idPart = $fileInfo.Name.Split('.')[0] # 取得第一個點前面的字串
          $debFileName = "$idPart.deb.0.5.full.txt"
          $debPath = Join-Path $fileInfo.DirectoryName $debFileName
          write-host "開始處理: $($debFileName)" -ForegroundColor Gray
          # 處理 .deb (全文比對)
          $debList = [System.Collections.Generic.List[string]]::new()
          if (Test-Path $debPath) {
            $debContent = Get-Content $debPath
            foreach ($line in $debContent) {
              if ([string]::IsNullOrWhiteSpace($line)) { continue }
              if ($line -match $debkeywordPattern) {
                $debList.Add($line.Trim())
              }
            }
          }
          # --- 合併與排序 ---
          $allMatches = $evtList + $debList
          $sortedResults = $allMatches | Sort-Object {
            # 使用正規表達式提取日期時間格式 (YY-MM-DD HH:MM:SS)
            if ($_ -match '(?<DateTime>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
              # 轉成 DateTime 物件進行精確的時間數值排序
              [DateTime]::ParseExact($Matches['DateTime'], "yy-MM-dd HH:mm:ss", $null)
            }
            else {
              # 如果該行沒有日期，排在最前面或最後面
              [DateTime]::MinValue
            }
          }

          $targetFileName = "${baseName}_${timestamp}_error.txt"
          # 完整儲存路徑：資料夾名稱 / 檔名
          $finalOutputPath = Join-Path $officeID $targetFileName

          # 將所有匹配的行內容寫入該個別檔案
          $sortedResults | Out-File -FilePath $finalOutputPath -Encoding utf8
                    
          # [新加入] 備份原始 .evt 檔
          # 目的地檔名維持原樣，但存放在 $officeID 下
          Copy-Item -Path $evtPath -Destination (Join-Path $officeID "${BaseName}_${timestamp}.txt") -Force
            
          # [新加入] 備份原始 .deb 檔 (如果存在)
          if (Test-Path $debPath) {
            $debFileInfo = Get-Item $debPath
            $debbaseName = $debFileInfo.BaseName # 不含副檔名的檔名
            Copy-Item -Path $debPath -Destination (Join-Path $officeID "${debbaseName}_${timestamp}.txt") -Force
          }
          write-host "[成功] $officeID \ $idPart -> 檔案已儲存" -ForegroundColor Green
        }
      }
      else {
        write-host "[跳過] 檔案: $($filePath) (Drive還沒失效)" -ForegroundColor Gray
      }
    }
    else {
      # 選項：可以顯示哪些檔案被忽略了
      if ($matchCount -gt 0) {
        write-host "[跳過] 檔案: $($filePath) (僅 $matchCount 行，未達門檻)" -ForegroundColor Gray
      }
    }
  }
}

# 3. 輸出總結報告
if ($summaryList.Count -gt 0) {
  $summaryList | Out-File -FilePath $summaryFile -Encoding utf8
  if ($summary1List.Count -gt 0) {
    $summary1List | Out-File -FilePath $summaryFile1 -Encoding utf8
    write-host "`n[完成] 總結報告已存至: $summaryFile1" -ForegroundColor Green
    write-host "[完成] 共處理了 $($summary1List.Count) 個包含錯誤的檔案。" -ForegroundColor Green
  }
}
else {
  write-host "`n未發現任何符合條件的檔案。" -ForegroundColor Yellow
}

pause