# Generated by Gemini
# 20260106 - first release

# 建立統計物件的函式
function New-EventSummary ($Entries) {
  $minSector = ($Entries | Sort-Object SectorDec)[0].SectorDec
  $duration = ($Entries | Sort-Object Time)[-1].Time - ($Entries | Sort-Object Time)[0].Time
  return [PSCustomObject]@{
    DriveID     = $Entries[0].ID
    StartSector = "0x{0:X}" -f $minSector
    SectorDec   = $minSector
    GB_Zone     = "GB_" + $Entries[0].GBZone
    StartGB     = $Entries[0].GBZone
    ErrorCount  = $Entries.Count
    StartTime   = ($Entries | Sort-Object Time)[0].Time
    EndTime     = ($Entries | Sort-Object Time)[-1].Time
    Duration    = "$([Math]::Round($duration.TotalDays, 1)) days"
  }
}

# EVENT ID
#220A0148: Drive fail
#220A0188: Drive Failure
#020AA182: clone
#320A4509: LD fatal
#12084204: Drive Event Detected-Starting Clone

#220A0749: Media Scan Failed
#22084202: No availible drive for cloning
#22084285: Drive Event Detected-Clone Failed
#22080581: Timeout Waiting for I/O to Complete
#21080282: Gross Phase/Signal Error Detected
#020A8305: Rebuild
#22081882

# 1. 設定關鍵字與檔案路徑
# media error
$keywords = @("02081382", "02081342", "02081341", "02081381")
# drive fail, rebuild, clone, io error
$keywords1 = @("21081282", "220A0188", "220A0187", "220A0185", "220A0148", "12084204")

# events we want
$keywords2 = @("02081382", "02081342", "02081341", "02081381", "21081282", "220A0188", "22080581", "020A8305", "020AA182", "320A4509", "220A0187", "22084205", "22084202", "020A8402", "21080282", "22080181", "220A1182", "12084243", "12084244", "020AA142", "020AA281", "220A0185", "12084204", "22080541", "22080542", "220A0148", "21080242", "22080141", "02081781", "22084285", "12084284", "220A0749", "22081882")

$debkeywords = @("M62:", "High latency detected")
$inputFile = "Search_Report_JP.txt"
$summaryFile = "Column7_Match_Result_JP.txt"
$summaryFile1 = "Column7_Match_Result1_JP.txt"
$minMatchCount = 20  # 設定門檻：少於 20 行則忽略

# 建立搜尋正則：鎖定第七欄
$keywordPattern = ($keywords | ForEach-Object { [regex]::Escape($_) }) -join '|'
$pattern = "^\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+($keywordPattern)"

$keywordPattern1 = ($keywords1 | ForEach-Object { [regex]::Escape($_) }) -join '|'
$pattern1 = "^\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+($keywordPattern1)"

$keywordPattern2 = ($keywords2 | ForEach-Object { [regex]::Escape($_) }) -join '|'
$pattern2 = "^\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+($keywordPattern2)"

$debkeywordPattern = ($debkeywords | ForEach-Object { [regex]::Escape($_) }) -join '|'

# 定義 1GB 所佔用的 Sector 數量 (以 512-byte sector 為例)
$SectorsPerGB = 2097152
$WeekThresholdDays = 7


write-host "開始分析檔案 (門檻：至少需包含 $minMatchCount 行匹配內容)..." -ForegroundColor Cyan

# 準備存儲總結結果的清單
$summaryList = New-Object System.Collections.Generic.List[string]
$summary1List = New-Object System.Collections.Generic.List[string]

# 2. 逐一處理 Search_Report.txt 中的檔案
Get-Content $inputFile | ForEach-Object {
  $evtPath = $_.Trim()
    
  if (Test-Path $evtPath) {
    # 搜尋該檔案中「所有」匹配的行
    $Pattern_matches = Select-String -Path $evtPath -Pattern $pattern -ErrorAction SilentlyContinue
    $matchCount = $Pattern_matches.Count
        
    if ($matchCount -ge $minMatchCount) {
      # --- 處理總結報告 (只取第一筆) ---
      $firstMatch = $Pattern_matches[0]
      $summaryList.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")

      # --- 排序 Media error ---
      # 假設 $Pattern_matches 是您從 Select-String 抓取出來的物件
      $sortedPatternMatchResult = $Pattern_matches | Sort-Object -Property @{
        # 1. 第一層：依據磁碟 ID 分組
        Expression = {
          if ($_.Line -match 'ID:(?<ID>\d+)') { [int64]$Matches['ID'] } else { 0 }
        }
      }, @{
        # 2. 第二層：1GB 區域對齊 (Grouping by GB range)
        Expression = {
          if ($_.Line -match '0x(?<Sector>[0-9A-Fa-f]+)') {
            $decSector = [Convert]::ToInt64($Matches['Sector'], 16)
            # 將 Sector 除以 1GB 的總數並取整數，得到「第幾個 GB」
            [Math]::Floor($decSector / $SectorsPerGB)
          }
          else { 0 }
        }
      }, @{
        # 3. 第三層：在同一個 1GB 區域內，按時間排序
        Expression = {
          if ($_.Line -match '(?<Date>\d{2}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})') {
            [DateTime]::ParseExact($Matches['Date'], "yy-MM-dd HH:mm:ss", $null)
          }
          else { [DateTime]::MinValue }
        }
      }

      # 1. 預處理：解析 Log 並轉為物件
      # 1. 預處理：解析 Log 並轉為物件 (支援 64-bit Sector)
      $parsedLogs = $Pattern_matches | ForEach-Object {
        $line = $_.Line
        $foundID = $null
        $foundTime = $null
        $foundSector = 0

        # 匹配 ID (精確抓取 ID:16, ID:17 等)
        if ($line -match 'ID:(?<ID>\d+)') {
          $foundID = [int64]$Matches['ID']
        }

        # 匹配日期時間 (YY-MM-DD HH:MM:SS)
        if ($line -match '(?<DT>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
          $foundTime = [DateTime]::ParseExact($Matches['DT'], "yy-MM-dd HH:mm:ss", $null)
        }

        # 匹配 Sector (支援 64-bit Hex，例如 0xFFFFFFFF 或更長位址)
        if ($line -match '0x(?<Hex>[0-9A-Fa-f]+)') {
          try {
            # 使用長整數處理位址
            $foundSector = [Convert]::ToInt64($Matches['Hex'], 16)
          }
          catch {
            $foundSector = 0 
          }
        }

        if ($null -ne $foundID -and $null -ne $foundTime) {
          [PSCustomObject]@{
            ID        = $foundID
            SectorDec = $foundSector
            SectorHex = "0x{0:X}" -f $foundSector
            GBZone    = [Math]::Floor($foundSector / $SectorsPerGB)
            Time      = $foundTime
            RawLine   = $line
          }
        }
      }

      # 2. 分組與事件處理
      $finalReport = @()
      $groups = $parsedLogs | Group-Object ID, GBZone

      foreach ($g in $groups) {
        # 區域內按 Sector 排序，確保分析連續性
        $sortedEntries = $g.Group | Sort-Object SectorDec, Time
    
        $currentEventEntries = @()
        $lastTime = $null

        foreach ($entry in $sortedEntries) {
          # 時間間隔判定：超過一週則分割
          if ($null -ne $lastTime -and [Math]::Abs(($entry.Time - $lastTime).TotalDays) -gt $WeekThresholdDays) {
            $finalReport += New-EventSummary -Entries $currentEventEntries
            $currentEventEntries = @()
          }
        
          $currentEventEntries += $entry
          $lastTime = $entry.Time
        }
    
        if ($currentEventEntries.Count -gt 0) {
          $finalReport += New-EventSummary -Entries $currentEventEntries
        }
      }


      # 3. 最終排序：先按 ID 排，再按 Sector 數值排
      $sortedFinalReport = $finalReport | Sort-Object DriveID, SectorDec

      # 4. 輸出結果
      $sortedFinalReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | Format-Table -AutoSize

      Write-Host "`n[統計摘要]" -ForegroundColor Cyan
      Write-Host "總受損 GB 區域數: " ($groups.Count)
      Write-Host "總事件處理數 (跨週分割): " ($finalReport.Count) -ForegroundColor Yellow

      $fileInfo = Get-Item $evtPath
      # --- A. 提取路徑中的 Office ID (例如 OFY-508427) ---
      $pathParts = $evtPath -split '\\'
      $officeID = if ($pathParts.Count -ge 6) { $pathParts[5] } else { "Unknown" }
      # --- B. 建立 Office ID 為名的資料夾 ---
      if (!(Test-Path $officeID)) {
        New-Item -ItemType Directory -Path $officeID -Force | Out-Null
        write-host "建立資料夾: $officeID" -ForegroundColor Gray
      }
      $baseName = $fileInfo.BaseName # 不含副檔名的檔名
      $timestamp = $fileInfo.CreationTime.ToString("yyyyMMdd_HHmmss")
      $patternMatchFileName = "${baseName}_${timestamp}_mediaerror.txt"
      $patternMatchOutPath = Join-Path $officeID $patternMatchFileName
      $Pattern_matches.Line | Out-File -FilePath $patternMatchOutPath -Encoding utf8

      $patternMatchFileName = "${baseName}_${timestamp}_mediaerror_sorted.txt"
      $patternMatchOutPath = Join-Path $officeID $patternMatchFileName

      # --- 產生表格化 Text 與 畫面顯示 ---
      $reportOutput = New-Object System.Collections.Generic.List[string]
      $reportOutput.Add("=== Disk Media Error Analysis Report (Grouped by ID) ===")
      $reportOutput.Add("Generated on: $(Get-Date)")
      $reportOutput.Add("Total number of damaged GB areas: $($groups.Count)")
      $reportOutput.Add("")

      # 按 ID 分組顯示
      $groupedByID = $finalReport | Sort-Object DriveID, SectorDec | Group-Object DriveID

      foreach ($driveGroup in $groupedByID) {
        $header = ">>> Drive ID: $($driveGroup.Name) (Total Events: $($driveGroup.Count))"
        $reportOutput.Add($header)
        $reportOutput.Add("-" * $header.Length)
    
        # 格式化該 ID 下的事件清單
        $table = $driveGroup.Group | Select-Object StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | Format-Table -AutoSize | Out-String
        $reportOutput.Add($table)
        $reportOutput.Add("") # 空行隔開不同 ID
      }

      # 3. 儲存與輸出
      $reportOutput | Out-File -FilePath $patternMatchOutPath -Encoding UTF8
      $reportOutput | Write-Host -ForegroundColor White # 直接在畫面上顯示

      $sortedPatternMatchResult.Line | Out-File -FilePath $patternMatchOutPath -Append -Encoding utf8

      # 定義檔名

      $csvFileName = "Disk_Error_Report_${baseName}_${timestamp}.csv"
      $csvFilePath = Join-Path $officeID $csvFileName

      # 將結果選取需要的欄位並匯出
      $sortedFinalReport | Select-Object DriveID, StartSector, GB_Zone, ErrorCount, StartTime, EndTime, Duration | 
      Export-Csv -Path $csvFilePath -NoTypeInformation -Encoding UTF8

      Write-Host "Excel 報表已儲存至: $csvFileName" -ForegroundColor Green

      $allMatches = Select-String -Path $evtPath -Pattern $pattern1 -List -ErrorAction SilentlyContinue
            
      if ( $allMatches) {
        # --- 使用 List 物件確保資料被抓取 ---
        $evtList = [System.Collections.Generic.List[string]]::new()
        
        # 逐行讀取 .evt
        $evtContent = Get-Content $evtPath
        foreach ($line in $evtContent) {
          $trimmedLine = $line.Trim()
            
          # 排除空行與星號開頭
          if ([string]::IsNullOrWhiteSpace($trimmedLine)) { continue }
            
          $cols = $trimmedLine -split '\s+'
            
          # 檢查第 7 欄 (索引 6)
          if ($cols.Count -ge 7) {
            if ($cols[6] -match $keywordPattern2) {
              $evtList.Add($trimmedLine) # 存入 List，不保留行首空白
            }
          }
        }
        # --- 新增判斷邏輯：僅處理達到門檻的檔案 ---
        if ( $evtList) {
          $summary1List.Add("$($firstMatch.Path) : $($firstMatch.Line.Trim())")

          # --- 處理個別錯誤檔案 (完整結果) ---
          $idPart = $fileInfo.Name.Split('.')[0] # 取得第一個點前面的字串
          $debFileName = "$idPart.deb.0.5.full.txt"
          $debPath = Join-Path $fileInfo.DirectoryName $debFileName
          write-host "開始處理: $($debFileName)" -ForegroundColor Gray
          # 處理 .deb (全文比對)
          $debList = [System.Collections.Generic.List[string]]::new()
          if (Test-Path $debPath) {
            $debContent = Get-Content $debPath
            foreach ($line in $debContent) {
              if ([string]::IsNullOrWhiteSpace($line)) { continue }
              if ($line -match $debkeywordPattern) {
                $debList.Add($line.Trim())
              }
            }
          }
          # --- 合併與排序 ---
          $allMatches = $evtList + $debList
            
          $sortedResults = $allMatches | Sort-Object {
            # 使用正規表達式提取日期時間格式 (YY-MM-DD HH:MM:SS)
            if ($_ -match '(?<DateTime>\d{2}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})') {
              # 轉成 DateTime 物件進行精確的時間數值排序
              [DateTime]::ParseExact($Matches['DateTime'], "yy-MM-dd HH:mm:ss", $null)
            }
            else {
              # 如果該行沒有日期，排在最前面或最後面
              [DateTime]::MinValue
            }
          }

          $targetFileName = "${baseName}_${timestamp}_error.txt"
          # 完整儲存路徑：資料夾名稱 / 檔名
          $finalOutputPath = Join-Path $officeID $targetFileName

          # 將所有匹配的行內容寫入該個別檔案
          $sortedResults | Out-File -FilePath $finalOutputPath -Encoding utf8
                    

          # [新加入] 備份原始 .evt 檔
          # 目的地檔名維持原樣，但存放在 $officeID 下
          Copy-Item -Path $evtPath -Destination (Join-Path $officeID "${BaseName}_${timestamp}.txt") -Force
            
          # [新加入] 備份原始 .deb 檔 (如果存在)
          if (Test-Path $debPath) {
            $debFileInfo = Get-Item $debPath
            $debbaseName = $debFileInfo.BaseName # 不含副檔名的檔名
            Copy-Item -Path $debPath -Destination (Join-Path $officeID "${debbaseName}_${timestamp}.txt") -Force
          }
          write-host "[成功] $officeID \ $idPart -> 檔案已儲存" -ForegroundColor Green
        }
      }
      else {
        write-host "[跳過] 檔案: $($filePath) (Drive還沒失效)" -ForegroundColor Gray
      }
    }
    else {
      # 選項：可以顯示哪些檔案被忽略了
      if ($matchCount -gt 0) {
        write-host "[跳過] 檔案: $($filePath) (僅 $matchCount 行，未達門檻)" -ForegroundColor Gray
      }
    }
  }
}

# 3. 輸出總結報告
if ($summaryList.Count -gt 0) {
  $summaryList | Out-File -FilePath $summaryFile -Encoding utf8
  if ($summary1List.Count -gt 0) {
    $summary1List | Out-File -FilePath $summaryFile1 -Encoding utf8
    write-host "`n[完成] 總結報告已存至: $summaryFile1" -ForegroundColor Green
    write-host "[完成] 共處理了 $($summary1List.Count) 個包含錯誤的檔案。" -ForegroundColor Green
  }
}
else {
  write-host "`n未發現任何符合條件的檔案。" -ForegroundColor Yellow
}

pause